diff --git a/src/libexpr/eval.cc b/src/libexpr/eval.cc
index 3b21c07..68688f7 100644
--- a/src/libexpr/eval.cc
+++ b/src/libexpr/eval.cc
@@ -5,12 +5,11 @@
 #include "derivations.hh"
 #include "globals.hh"
 #include "eval-inline.hh"
+#include "download.hh"
+
 
 #include <algorithm>
 #include <cstring>
-#include <unistd.h>
-#include <sys/time.h>
-#include <sys/resource.h>
 
 #if HAVE_BOEHMGC
 
@@ -25,6 +24,8 @@
 
 #endif
 
+/* Genode includes */
+#include <os/config.h>
 
 namespace nix {
 
@@ -57,8 +58,6 @@ static void * allocBytes(size_t n)
 
 static void printValue(std::ostream & str, std::set<const Value *> & active, const Value & v)
 {
-    checkInterrupt();
-
     if (active.find(&v) != active.end()) {
         str << "<CYCLE>";
         return;
@@ -244,8 +243,9 @@ static Strings parseNixPath(const string & in)
 }
 
 
-EvalState::EvalState(const Strings & _searchPath)
-    : sWith(symbols.create("<with>"))
+EvalState::EvalState(Store &store, Genode::Xml_node config_node)
+    : _store(store)
+    , sWith(symbols.create("<with>"))
     , sOutPath(symbols.create("outPath"))
     , sDrvPath(symbols.create("drvPath"))
     , sType(symbols.create("type"))
@@ -265,17 +265,27 @@ EvalState::EvalState(const Strings & _searchPath)
     , baseEnv(allocEnv(128))
     , staticBaseEnv(false, 0)
 {
+    if (_vfs == nullptr)
+      throw Error("Nix VFS uninitialized");
+
     countCalls = getEnv("NIX_COUNT_CALLS", "0") != "0";
 
     restricted = settings.get("restrict-eval", false);
 
+    initGC();
     assert(gcInitialised);
 
-    /* Initialise the Nix expression search path. */
-    Strings paths = parseNixPath(getEnv("NIX_PATH", ""));
-    for (auto & i : _searchPath) addToSearchPath(i, true);
-    for (auto & i : paths) addToSearchPath(i);
-    addToSearchPath("nix=" + settings.nixDataDir + "/nix/corepkgs");
+	/* XXX: addToSearchPath faults
+    config_node.for_each_sub_node("search-path", [this] (Genode::Xml_node node) {
+        Genode::String<256> search_name;
+        Genode::String<1024> search_path;
+        try {
+            node.attribute("name").value(&search_name);
+            node.attribute("path").value(&search_path);
+        } catch (...) { return; }
+        this->addToSearchPath(search_name.string(), search_path.string(), true);
+    });
+	 */
 
     clearValue(vEmptySet);
     vEmptySet.type = tAttrs;
@@ -288,6 +298,72 @@ EvalState::EvalState(const Strings & _searchPath)
 EvalState::~EvalState()
 {
     fileEvalCache.clear();
+    romEvalCache.clear();
+}
+
+
+void EvalState::addToSearchPath(const string & s, bool warn)
+{
+    size_t pos = s.find('=');
+    string prefix;
+    Path path;
+    if (pos == string::npos) {
+        path = s;
+    } else {
+        prefix = string(s, 0, pos);
+        path = string(s, pos + 1);
+    }
+
+    addToSearchPath(prefix, path, warn);
+}
+
+
+void EvalState::addToSearchPath(const string & name, const string & value, bool warn)
+{
+   Path path = isUri(path) ? downloadFileCached(path, true) : path;
+
+    path = absPath(path);
+    if (pathExists(path)) {
+        debug(format("adding path ‘%1%’ to the search path") % path);
+        /* Resolve symlinks in the path to support restricted mode. */
+        searchPath.push_back(std::pair<string, Path>(name, canonPath(path, true)));
+    } else if (warn)
+        printMsg(lvlError, format("warning: Nix search path entry ‘%1%’ does not exist, ignoring") % path);
+}
+
+
+Path EvalState::findFile(const string & path)
+{
+    return findFile(searchPath, path);
+}
+
+
+Path EvalState::findFile(SearchPath & searchPath, const string & path, const Pos & pos)
+{
+    for (auto & i : searchPath) {
+        assert(!isUri(i.second));
+        Path res;
+        if (i.first.empty())
+            res = i.second + "/" + path;
+        else {
+            if (path.compare(0, i.first.size(), i.first) != 0 ||
+                (path.size() > i.first.size() && path[i.first.size()] != '/'))
+                continue;
+            res = i.second +
+                (path.size() == i.first.size() ? "" : "/" + string(path, i.first.size()));
+        }
+        if (pathExists(res)) return canonPath(res);
+    }
+    /* fallback to '/<...>' */
+    {
+        Path abs_path = canonPath("/"+path);
+        if (pathExists(abs_path)) return abs_path;
+    }
+    format f = format(
+        "file ‘%1%’ was not found in the Nix search path (add it using $NIX_PATH or -I)"
+        + string(pos ? ", at %2%" : ""));
+    f.exceptions(boost::io::all_error_bits ^ boost::io::too_many_args_bit);
+    throw ThrownError(f % path % pos);
 }
 
 
@@ -619,6 +695,12 @@ void EvalState::resetFileCache()
 }
 
 
+void EvalState::resetRomCache()
+{
+    romEvalCache.clear();
+}
+
+
 void EvalState::eval(Expr * e, Value & v)
 {
     e->eval(*this, baseEnv, v);
@@ -1443,7 +1525,7 @@ string EvalState::copyPathToStore(PathSet & context, const Path & path)
     else {
         dstPath = settings.readOnlyMode
             ? computeStorePathForPath(checkSourcePath(path)).first
-            : store->addToStore(baseNameOf(path), checkSourcePath(path), true, htSHA256, defaultPathFilter, repair);
+            : _store.addToStore(baseNameOf(path), checkSourcePath(path), true, htBLAKE2s, defaultPathFilter, repair);
         srcToStore[path] = dstPath;
         printMsg(lvlChatty, format("copied source ‘%1%’ -> ‘%2%’")
             % path % dstPath);
@@ -1457,8 +1539,8 @@ string EvalState::copyPathToStore(PathSet & context, const Path & path)
 Path EvalState::coerceToPath(const Pos & pos, Value & v, PathSet & context)
 {
     string path = coerceToString(pos, v, context, false, false);
-    if (path == "" || path[0] != '/')
-        throwEvalError("string ‘%1%’ doesn't represent an absolute path, at %2%", path, pos);
+    if (path == "")
+        throwEvalError("empty path at %1%", pos);
     return path;
 }
 
@@ -1542,9 +1624,7 @@ void EvalState::printStats()
     Verbosity v = showStats ? lvlInfo : lvlDebug;
     printMsg(v, "evaluation statistics:");
 
-    struct rusage buf;
-    getrusage(RUSAGE_SELF, &buf);
-    float cpuTime = buf.ru_utime.tv_sec + ((float) buf.ru_utime.tv_usec / 1000000);
+    float cpuTime = 0;
 
     uint64_t bEnvs = nrEnvs * sizeof(Env) + nrValuesInEnvs * sizeof(Value *);
     uint64_t bLists = nrListElems * sizeof(Value *);
diff --git a/src/libexpr/eval.hh b/src/libexpr/eval.hh
index 2d7b7bc..567a8e9 100644
--- a/src/libexpr/eval.hh
+++ b/src/libexpr/eval.hh
@@ -5,6 +5,7 @@
 #include "nixexpr.hh"
 #include "symbol-table.hh"
 #include "hash.hh"
+#include "store.hh"
 
 #include <map>
 
@@ -83,24 +84,35 @@ public:
     Value vEmptySet;
 
 private:
+    Store    &_store;
+
     SrcToStore srcToStore;
 
+public:
     /* A cache from path names to values. */
 #if HAVE_BOEHMGC
     typedef std::map<Path, Value, std::less<Path>, traceable_allocator<std::pair<const Path, Value> > > FileEvalCache;
+    typedef std::map<string, Value, std::less<string>, traceable_allocator<std::pair<const string, Value> > > RomEvalCache;
 #else
     typedef std::map<Path, Value> FileEvalCache;
+    typedef std::map<string, Value> RomEvalCache;
 #endif
+private:
     FileEvalCache fileEvalCache;
+public:
+    RomEvalCache  romEvalCache;
 
     SearchPath searchPath;
 
 public:
 
-    EvalState(const Strings & _searchPath);
+    EvalState(Store &store, Genode::Xml_node config_node);
     ~EvalState();
 
+    Store    &store() { return _store; };
+
     void addToSearchPath(const string & s, bool warn = false);
+    void addToSearchPath(const string & name, const string & path, bool warn = false);
 
     Path checkSourcePath(const Path & path);
 
@@ -117,6 +129,7 @@ public:
     void evalFile(const Path & path, Value & v);
 
     void resetFileCache();
+    void resetRomCache();
 
     /* Look up a file in the search path. */
     Path findFile(const string & path);
diff --git a/src/libexpr/parser.y b/src/libexpr/parser.y
index d34882f..ceebf6e 100644
--- a/src/libexpr/parser.y
+++ b/src/libexpr/parser.y
@@ -282,6 +282,7 @@ void yyerror(YYLTYPE * loc, yyscan_t scanner, ParseData * data, const char * err
 %left '*' '/'
 %right CONCAT
 %nonassoc '?'
+%nonassoc '~'
 %nonassoc NEGATE
 
 %%
@@ -371,7 +372,6 @@ expr_simple
       $$ = stripIndentation(CUR_POS, data->symbols, *$2);
   }
   | PATH { $$ = new ExprPath(absPath($1, data->basePath)); }
-  | HPATH { $$ = new ExprPath(getEnv("HOME", "") + string{$1 + 1}); }
   | SPATH {
       string path($1 + 1, strlen($1) - 2);
       $$ = new ExprApp(CUR_POS,
@@ -510,13 +510,7 @@ formal
 %%
 
 
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <unistd.h>
-
 #include <eval.hh>
-#include <download.hh>
 #include <store-api.hh>
 
 
@@ -547,19 +541,19 @@ Expr * EvalState::parse(const char * text,
 Path resolveExprPath(Path path)
 {
     assert(path[0] == '/');
+    Vfs::Directory_service::Stat stat;
 
     /* If `path' is a symlink, follow it.  This is so that relative
        path references work. */
-    struct stat st;
-    while (true) {
-        if (lstat(path.c_str(), &st))
-            throw SysError(format("getting status of ‘%1%’") % path);
-        if (!S_ISLNK(st.st_mode)) break;
-        path = absPath(readLink(path), dirOf(path));
+    for (;;) {
+        stat = status(path);
+        if (S_ISLNK(stat.mode))
+            path = absPath(readLink(path), dirOf(path));
+        else break;
     }
 
     /* If `path' refers to a directory, append `/default.nix'. */
-    if (S_ISDIR(st.st_mode))
+    if (S_ISDIR(stat.mode))
         path = canonPath(path + "/default.nix");
 
     return path;
@@ -590,59 +584,4 @@ Expr * EvalState::parseExprFromString(const string & s, const Path & basePath)
 }
 
 
-void EvalState::addToSearchPath(const string & s, bool warn)
-{
-    size_t pos = s.find('=');
-    string prefix;
-    Path path;
-    if (pos == string::npos) {
-        path = s;
-    } else {
-        prefix = string(s, 0, pos);
-        path = string(s, pos + 1);
-    }
-
-    if (isUri(path))
-        path = downloadFileCached(path, true);
-
-    path = absPath(path);
-    if (pathExists(path)) {
-        debug(format("adding path ‘%1%’ to the search path") % path);
-        /* Resolve symlinks in the path to support restricted mode. */
-        searchPath.push_back(std::pair<string, Path>(prefix, canonPath(path, true)));
-    } else if (warn)
-        printMsg(lvlError, format("warning: Nix search path entry ‘%1%’ does not exist, ignoring") % path);
-}
-
-
-Path EvalState::findFile(const string & path)
-{
-    return findFile(searchPath, path);
-}
-
-
-Path EvalState::findFile(SearchPath & searchPath, const string & path, const Pos & pos)
-{
-    for (auto & i : searchPath) {
-        assert(!isUri(i.second));
-        Path res;
-        if (i.first.empty())
-            res = i.second + "/" + path;
-        else {
-            if (path.compare(0, i.first.size(), i.first) != 0 ||
-                (path.size() > i.first.size() && path[i.first.size()] != '/'))
-                continue;
-            res = i.second +
-                (path.size() == i.first.size() ? "" : "/" + string(path, i.first.size()));
-        }
-        if (pathExists(res)) return canonPath(res);
-    }
-    format f = format(
-        "file ‘%1%’ was not found in the Nix search path (add it using $NIX_PATH or -I)"
-        + string(pos ? ", at %2%" : ""));
-    f.exceptions(boost::io::all_error_bits ^ boost::io::too_many_args_bit);
-    throw ThrownError(f % path % pos);
-}
-
-
 }
diff --git a/src/libexpr/primops.cc b/src/libexpr/primops.cc
index 87ee4f6..9ef8651 100644
--- a/src/libexpr/primops.cc
+++ b/src/libexpr/primops.cc
@@ -19,6 +19,9 @@
 #include <cstring>
 #include <dlfcn.h>
 
+/* Genode includes */
+#include <os/attached_rom_dataspace.h>
+
 
 namespace nix {
 
@@ -43,14 +46,14 @@ std::pair<string, string> decodeContext(const string & s)
 InvalidPathError::InvalidPathError(const Path & path) :
     EvalError(format("path ‘%1%’ is not valid") % path), path(path) {}
 
-void realiseContext(const PathSet & context)
+void realiseContext(Store &store, const PathSet & context)
 {
     PathSet drvs;
     for (auto & i : context) {
         std::pair<string, string> decoded = decodeContext(i);
         Path ctx = decoded.first;
         assert(isStorePath(ctx));
-        if (!store->isValidPath(ctx))
+        if (!store.isValidPath(ctx))
             throw InvalidPathError(ctx);
         if (!decoded.second.empty() && isDerivation(ctx))
             drvs.insert(decoded.first + "!" + decoded.second);
@@ -59,10 +62,10 @@ void realiseContext(const PathSet & context)
         /* For performance, prefetch all substitute info. */
         PathSet willBuild, willSubstitute, unknown;
         unsigned long long downloadSize, narSize;
-        queryMissing(*store, drvs,
+        queryMissing(store, drvs,
             willBuild, willSubstitute, unknown, downloadSize, narSize);
 
-        store->buildPaths(drvs);
+        store.buildPaths(drvs);
     }
 }
 
@@ -75,7 +78,7 @@ static void prim_scopedImport(EvalState & state, const Pos & pos, Value * * args
     Path path = state.coerceToPath(pos, *args[1], context);
 
     try {
-        realiseContext(context);
+        realiseContext(state.store(), context);
     } catch (InvalidPathError & e) {
         throw EvalError(format("cannot import ‘%1%’, since path ‘%2%’ is not valid, at %3%")
             % path % e.path % pos);
@@ -83,7 +86,7 @@ static void prim_scopedImport(EvalState & state, const Pos & pos, Value * * args
 
     path = state.checkSourcePath(path);
 
-    if (isStorePath(path) && store->isValidPath(path) && isDerivation(path)) {
+    if (isStorePath(path) && state.store().isValidPath(path) && isDerivation(path)) {
         Derivation drv = readDerivation(path);
         Value & w = *state.allocValue();
         state.mkAttrs(w, 3 + drv.outputs.size());
@@ -145,7 +148,7 @@ static void prim_importNative(EvalState & state, const Pos & pos, Value * * args
     Path path = state.coerceToPath(pos, *args[0], context);
 
     try {
-        realiseContext(context);
+        realiseContext(state.store(), context);
     } catch (InvalidPathError & e) {
         throw EvalError(format("cannot import ‘%1%’, since path ‘%2%’ is not valid, at %3%")
             % path % e.path % pos);
@@ -383,11 +386,30 @@ static void prim_tryEval(EvalState & state, const Pos & pos, Value * * args, Val
 }
 
 
-/* Return an environment variable.  Use with care. */
-static void prim_getEnv(EvalState & state, const Pos & pos, Value * * args, Value & v)
+/* Convert a ROM session to a store object. */
+static void prim_getRom(EvalState & state, const Pos & pos, Value * * args, Value & v)
 {
+    using namespace Genode;
+
     string name = state.forceStringNoCtx(*args[0], pos);
-    mkString(v, state.restricted ? "" : getEnv(name));
+    EvalState::RomEvalCache::iterator i;
+    if ((i = state.romEvalCache.find(name)) != state.romEvalCache.end()) {
+        v = i->second;
+        return;
+    }
+
+    try {
+               Genode::Attached_rom_dataspace rom(name.c_str());
+
+        string storeName = state.store().addDataToStore(
+            name, rom.local_addr<void>(), rom.size(), state.repair);
+
+        mkString(v, storeName);
+        state.romEvalCache[name] = v;
+    } catch (...) {
+		throw EvalError(format("failed to add ROM dataspace `%1%' to store at %2%")
+             % name % pos);
+    };
 }
 
 
@@ -560,11 +582,11 @@ static void prim_derivationStrict(EvalState & state, const Pos & pos, Value * *
            runs. */
         if (path.at(0) == '=') {
             /* !!! This doesn't work if readOnlyMode is set. */
-            PathSet refs; computeFSClosure(*store, string(path, 1), refs);
+            PathSet refs; computeFSClosure(state.store(), string(path, 1), refs);
             for (auto & j : refs) {
                 drv.inputSrcs.insert(j);
                 if (isDerivation(j))
-                    drv.inputDrvs[j] = store->queryDerivationOutputNames(j);
+                    drv.inputDrvs[j] = state.store().queryDerivationOutputNames(j);
             }
         }
 
@@ -581,7 +603,7 @@ static void prim_derivationStrict(EvalState & state, const Pos & pos, Value * *
         /* Handle derivation contexts returned by
            ‘builtins.storePath’. */
         else if (isDerivation(path))
-            drv.inputDrvs[path] = store->queryDerivationOutputNames(path);
+            drv.inputDrvs[path] = state.store().queryDerivationOutputNames(path);
 
         /* Otherwise it's a source file. */
         else
@@ -630,7 +652,7 @@ static void prim_derivationStrict(EvalState & state, const Pos & pos, Value * *
 
         /* Use the masked derivation expression to compute the output
            path. */
-        Hash h = hashDerivationModulo(*store, drv);
+        Hash h = hashDerivationModulo(state.store(), drv);
 
         for (auto & i : drv.outputs)
             if (i.second.path == "") {
@@ -641,7 +663,7 @@ static void prim_derivationStrict(EvalState & state, const Pos & pos, Value * *
     }
 
     /* Write the resulting term into the Nix store directory. */
-    Path drvPath = writeDerivation(*store, drv, drvName, state.repair);
+    Path drvPath = writeDerivation(state.store(), drv, drvName, state.repair);
 
     printMsg(lvlChatty, format("instantiated ‘%1%’ -> ‘%2%’")
         % drvName % drvPath);
@@ -649,7 +671,7 @@ static void prim_derivationStrict(EvalState & state, const Pos & pos, Value * *
     /* Optimisation, but required in read-only mode! because in that
        case we don't actually write store derivations, so we can't
        read them later. */
-    drvHashes[drvPath] = hashDerivationModulo(*store, drv);
+    drvHashes[drvPath] = hashDerivationModulo(state.store(), drv);
 
     state.mkAttrs(v, 1 + drv.outputs.size());
     mkString(*state.allocAttr(v, state.sDrvPath), drvPath, singleton<PathSet>("=" + drvPath));
@@ -695,7 +717,7 @@ static void prim_storePath(EvalState & state, const Pos & pos, Value * * args, V
         throw EvalError(format("path ‘%1%’ is not in the Nix store, at %2%") % path % pos);
     Path path2 = toStorePath(path);
     if (!settings.readOnlyMode)
-        store->ensurePath(path2);
+        state.store().ensurePath(path2);
     context.insert(path2);
     mkString(v, path, context);
 }
@@ -745,7 +767,7 @@ static void prim_readFile(EvalState & state, const Pos & pos, Value * * args, Va
     PathSet context;
     Path path = state.coerceToPath(pos, *args[0], context);
     try {
-        realiseContext(context);
+        realiseContext(state.store(), context);
     } catch (InvalidPathError & e) {
         throw EvalError(format("cannot read ‘%1%’, since path ‘%2%’ is not valid, at %3%")
             % path % e.path % pos);
@@ -786,7 +808,7 @@ static void prim_findFile(EvalState & state, const Pos & pos, Value * * args, Va
     string path = state.forceStringNoCtx(*args[1], pos);
 
     try {
-        realiseContext(context);
+        realiseContext(state.store(), context);
     } catch (InvalidPathError & e) {
         throw EvalError(format("cannot find ‘%1%’, since path ‘%2%’ is not valid, at %3%")
             % path % e.path % pos);
@@ -801,7 +823,7 @@ static void prim_readDir(EvalState & state, const Pos & pos, Value * * args, Val
     PathSet ctx;
     Path path = state.coerceToPath(pos, *args[0], ctx);
     try {
-        realiseContext(ctx);
+        realiseContext(state.store(), ctx);
     } catch (InvalidPathError & e) {
         throw EvalError(format("cannot read ‘%1%’, since path ‘%2%’ is not valid, at %3%")
             % path % e.path % pos);
@@ -812,12 +834,10 @@ static void prim_readDir(EvalState & state, const Pos & pos, Value * * args, Val
 
     for (auto & ent : entries) {
         Value * ent_val = state.allocAttr(v, state.symbols.create(ent.name));
-        if (ent.type == DT_UNKNOWN)
-            ent.type = getFileType(path + "/" + ent.name);
         mkStringNoCopy(*ent_val,
-            ent.type == DT_REG ? "regular" :
-            ent.type == DT_DIR ? "directory" :
-            ent.type == DT_LNK ? "symlink" :
+            ent.type == Dirent_type::DIRENT_TYPE_FILE ? "regular" :
+            ent.type == Dirent_type::DIRENT_TYPE_DIRECTORY ? "directory" :
+            ent.type == Dirent_type::DIRENT_TYPE_SYMLINK ? "symlink" :
             "unknown");
     }
 
@@ -885,7 +905,7 @@ static void prim_toFile(EvalState & state, const Pos & pos, Value * * args, Valu
 
     Path storePath = settings.readOnlyMode
         ? computeStorePathForText(name, contents, refs)
-        : store->addTextToStore(name, contents, refs, state.repair);
+        : state.store().addTextToStore(name, contents, refs, state.repair);
 
     /* Note: we don't need to add `context' to the context of the
        result, since `storePath' itself has references to the paths
@@ -950,8 +970,8 @@ static void prim_filterSource(EvalState & state, const Pos & pos, Value * * args
     path = state.checkSourcePath(path);
 
     Path dstPath = settings.readOnlyMode
-        ? computeStorePathForPath(path, true, htSHA256, filter).first
-        : store->addToStore(baseNameOf(path), path, true, htSHA256, filter, state.repair);
+        ? computeStorePathForPath(path, true, htBLAKE2s, filter).first
+        : state.store().addToStore(baseNameOf(path), path, true, htBLAKE2s, filter, state.repair);
 
     mkString(v, dstPath, singleton<PathSet>(dstPath));
 }
@@ -1759,7 +1779,7 @@ void EvalState::createBaseEnv()
     addPrimOp("throw", 1, prim_throw);
     addPrimOp("__addErrorContext", 2, prim_addErrorContext);
     addPrimOp("__tryEval", 1, prim_tryEval);
-    addPrimOp("__getEnv", 1, prim_getEnv);
+    addPrimOp("__getRom", 1, prim_getRom);
 
     // Strictness
     addPrimOp("__seq", 2, prim_seq);
