diff --git a/src/libutil/archive.cc b/src/libutil/archive.cc
index 6ee7981..578662f 100644
--- a/src/libutil/archive.cc
+++ b/src/libutil/archive.cc
@@ -9,12 +9,6 @@
 
 #include <strings.h> // for strcasecmp
 
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <dirent.h>
-#include <fcntl.h>
-
 #include "archive.hh"
 #include "util.hh"
 
@@ -39,18 +33,27 @@ PathFilter defaultPathFilter;
 static void dumpContents(const Path & path, size_t size,
     Sink & sink)
 {
-    sink << "contents" << size;
+    using namespace Vfs;
+
+    Vfs_handle *handle = nullptr;
+    if (_vfs->open(path.c_str(), Directory_service::OPEN_MODE_RDONLY, &handle)
+        != Vfs::Directory_service::OPEN_OK)
+        throw SysError(format("opening file ‘%1%’") % path);
+
+    Vfs_handle::Guard guard(handle);
 
-    AutoCloseFD fd = open(path.c_str(), O_RDONLY);
-    if (fd == -1) throw SysError(format("opening file ‘%1%’") % path);
+    sink << "contents" << size;
 
     unsigned char buf[65536];
     size_t left = size;
 
+    file_size n;
     while (left > 0) {
-        size_t n = left > sizeof(buf) ? sizeof(buf) : left;
-        readFull(fd, buf, n);
+        if (handle->fs().read(handle, (char *)buf, sizeof(buf), n) != File_io_service::READ_OK)
+            throw Error(format("reading file ‘%1%’") % path);
+
         left -= n;
+        if (left) handle->seek(n);
         sink(buf, n);
     }
 
@@ -60,20 +63,18 @@ static void dumpContents(const Path & path, size_t size,
 
 static void dump(const Path & path, Sink & sink, PathFilter & filter)
 {
-    struct stat st;
-    if (lstat(path.c_str(), &st))
-        throw SysError(format("getting attributes of path ‘%1%’") % path);
+    using namespace Vfs;
+
+    Directory_service::Stat st = status(path);
 
     sink << "(";
 
-    if (S_ISREG(st.st_mode)) {
+    if (S_ISREG(st.mode)) {
         sink << "type" << "regular";
-        if (st.st_mode & S_IXUSR)
-            sink << "executable" << "";
-        dumpContents(path, (size_t) st.st_size, sink);
+        dumpContents(path, (size_t) st.size, sink);
     }
 
-    else if (S_ISDIR(st.st_mode)) {
+    else if (S_ISDIR(st.mode)) {
         sink << "type" << "directory";
 
         /* If we're on a case-insensitive system like Mac OS X, undo
@@ -82,7 +83,7 @@ static void dump(const Path & path, Sink & sink, PathFilter & filter)
         for (auto & i : readDirectory(path))
             if (useCaseHack) {
                 string name(i.name);
-                size_t pos = i.name.find(caseHackSuffix);
+                size_t pos = name.find(caseHackSuffix);
                 if (pos != string::npos) {
                     printMsg(lvlDebug, format("removing case hack suffix from ‘%1%’") % (path + "/" + i.name));
                     name.erase(pos);
@@ -102,7 +103,7 @@ static void dump(const Path & path, Sink & sink, PathFilter & filter)
             }
     }
 
-    else if (S_ISLNK(st.st_mode))
+    else if (S_ISLNK(st.mode))
         sink << "type" << "symlink" << "target" << readLink(path);
 
     else throw Error(format("file ‘%1%’ has an unsupported type") % path);
@@ -215,7 +216,6 @@ static void parse(ParseSink & sink, Source & source, const Path & path)
 
         else if (s == "executable" && type == tpRegular) {
             readString(source);
-            sink.isExecutable();
         }
 
         else if (s == "entry" && type == tpDirectory) {
@@ -284,30 +284,34 @@ void parseDump(ParseSink & sink, Source & source)
 struct RestoreSink : ParseSink
 {
     Path dstPath;
-    AutoCloseFD fd;
+    Vfs::Vfs_handle *handle;
+
+    RestoreSink() : handle(nullptr) { }
+
+    ~RestoreSink()
+    {
+        if (handle)
+            destroy(Genode::env()->heap(), handle);
+    }
 
     void createDirectory(const Path & path)
     {
         Path p = dstPath + path;
-        if (mkdir(p.c_str(), 0777) == -1)
+        if (_vfs->mkdir(p.c_str(), 0777) != Vfs::Directory_service::Mkdir_result::MKDIR_OK)
             throw SysError(format("creating directory ‘%1%’") % p);
     };
 
     void createRegularFile(const Path & path)
     {
-        Path p = dstPath + path;
-        fd.close();
-        fd = open(p.c_str(), O_CREAT | O_EXCL | O_WRONLY, 0666);
-        if (fd == -1) throw SysError(format("creating file ‘%1%’") % p);
-    }
+        using namespace Vfs;
 
-    void isExecutable()
-    {
-        struct stat st;
-        if (fstat(fd, &st) == -1)
-            throw SysError("fstat");
-        if (fchmod(fd, st.st_mode | (S_IXUSR | S_IXGRP | S_IXOTH)) == -1)
-            throw SysError("fchmod");
+        if (handle)
+            destroy(Genode::env()->heap(), handle);
+
+        Path p = dstPath + path;
+        enum { MODE = Directory_service::OPEN_MODE_WRONLY | Directory_service::OPEN_MODE_CREATE };
+        if (_vfs->open(path.c_str(), MODE, &handle) != Directory_service::OPEN_OK)
+            throw SysError(format("creating file ‘%1%’") % p);
     }
 
     void preallocateContents(unsigned long long len)
@@ -327,7 +331,7 @@ struct RestoreSink : ParseSink
 
     void receiveContents(unsigned char * data, unsigned int len)
     {
-        writeFull(fd, data, len);
+        writeFull(handle, data, len);
     }
 
     void createSymlink(const Path & path, const string & target)
diff --git a/src/libutil/archive.hh b/src/libutil/archive.hh
index c216e97..3fb5111 100644
--- a/src/libutil/archive.hh
+++ b/src/libutil/archive.hh
@@ -2,6 +2,7 @@
 
 #include "types.hh"
 #include "serialise.hh"
+#include "util.hh"
 
 
 namespace nix {
diff --git a/src/libutil/hash.cc b/src/libutil/hash.cc
index 2d97c5e..9b4f297 100644
--- a/src/libutil/hash.cc
+++ b/src/libutil/hash.cc
@@ -33,6 +33,7 @@ Hash::Hash(HashType type)
     else if (type == htSHA1) hashSize = sha1HashSize;
     else if (type == htSHA256) hashSize = sha256HashSize;
     else if (type == htSHA512) hashSize = sha512HashSize;
+    else if (type == htBLAKE2S) hashSize = blake2sHashSize;
     else throw Error("unknown hash type");
     assert(hashSize <= maxHashSize);
     memset(hash, 0, maxHashSize);
@@ -240,13 +241,11 @@ Hash hashFile(HashType ht, const Path & path)
     Hash hash(ht);
     start(ht, ctx);
 
-    AutoCloseFD fd = open(path.c_str(), O_RDONLY);
-    if (fd == -1) throw SysError(format("opening file ‘%1%’") % path);
+    AutoCloseHandle handle(path, Vfs::Directory_service::OPEN_MODE_RDONLY);
 
     unsigned char buf[8192];
     ssize_t n;
-    while ((n = read(fd, buf, sizeof(buf)))) {
-        checkInterrupt();
+    while ((n = handle.read(buf, sizeof(buf)))) {
         if (n == -1) throw SysError(format("reading file ‘%1%’") % path);
         update(ht, ctx, buf, n);
     }
@@ -318,6 +317,7 @@ HashType parseHashType(const string & s)
     else if (s == "sha1") return htSHA1;
     else if (s == "sha256") return htSHA256;
     else if (s == "sha512") return htSHA512;
+    else if (s == "blake2s") return htBLAKE2S;
     else return htUnknown;
 }
 
@@ -328,6 +328,7 @@ string printHashType(HashType ht)
     else if (ht == htSHA1) return "sha1";
     else if (ht == htSHA256) return "sha256";
     else if (ht == htSHA512) return "sha512";
+    else if (ht == htBLAKE2S) return "blake2s";
     else throw Error("cannot print unknown hash type");
 }
 
diff --git a/src/libutil/hash.hh b/src/libutil/hash.hh
index 841b4cb..d1d46e7 100644
--- a/src/libutil/hash.hh
+++ b/src/libutil/hash.hh
@@ -7,13 +7,16 @@
 namespace nix {
 
 
-typedef enum { htUnknown, htMD5, htSHA1, htSHA256, htSHA512 } HashType;
+typedef enum { htUnknown, htMD5, htSHA1, htSHA256, htSHA512, htBLAKE2S } HashType;
+
+HashType const htDEFAULT = htBLAKE2S;
 
 
 const int md5HashSize = 16;
 const int sha1HashSize = 20;
 const int sha256HashSize = 32;
 const int sha512HashSize = 64;
+const int blake2sHashSize = 32;
 
 extern const string base32Chars;
 
diff --git a/src/libutil/regex.hh b/src/libutil/regex.hh
index 53e31f4..8cab7be 100644
--- a/src/libutil/regex.hh
+++ b/src/libutil/regex.hh
@@ -2,7 +2,6 @@
 
 #include "types.hh"
 
-#include <sys/types.h>
 #include <regex.h>
 
 #include <map>
diff --git a/src/libutil/serialise.cc b/src/libutil/serialise.cc
index f136a13..93618eb 100644
--- a/src/libutil/serialise.cc
+++ b/src/libutil/serialise.cc
@@ -48,12 +48,6 @@ void BufferedSink::flush()
 }
 
 
-FdSink::~FdSink()
-{
-    try { flush(); } catch (...) { ignoreException(); }
-}
-
-
 size_t threshold = 256 * 1024 * 1024;
 
 static void warnLargeDump()
@@ -62,19 +56,6 @@ static void warnLargeDump()
 }
 
 
-void FdSink::write(const unsigned char * data, size_t len)
-{
-    static bool warned = false;
-    if (warn && !warned) {
-        written += len;
-        if (written > threshold) {
-            warnLargeDump();
-            warned = true;
-        }
-    }
-    writeFull(fd, data, len);
-}
-
 
 void Source::operator () (unsigned char * data, size_t len)
 {
@@ -112,19 +93,6 @@ bool BufferedSource::hasData()
 }
 
 
-size_t FdSource::readUnbuffered(unsigned char * data, size_t len)
-{
-    ssize_t n;
-    do {
-        checkInterrupt();
-        n = ::read(fd, (char *) data, bufSize);
-    } while (n == -1 && errno == EINTR);
-    if (n == -1) throw SysError("reading from file");
-    if (n == 0) throw EndOfFile("unexpected end-of-file");
-    return n;
-}
-
-
 size_t StringSource::read(unsigned char * data, size_t len)
 {
     if (pos == s.size()) throw EndOfFile("end of string reached");
diff --git a/src/libutil/util.cc b/src/libutil/util.cc
index 16d3296..ba5ecbe 100644
--- a/src/libutil/util.cc
+++ b/src/libutil/util.cc
@@ -10,18 +10,8 @@
 #include <sstream>
 #include <cstring>
 
-#include <sys/wait.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <limits.h>
-
-#ifdef __APPLE__
-#include <sys/syscall.h>
-#endif
-
-#ifdef __linux__
-#include <sys/prctl.h>
-#endif
+/* Genode includes */
+#include <os/config.h>
 
 
 extern char * * environ;
@@ -29,6 +19,8 @@ extern char * * environ;
 
 namespace nix {
 
+Vfs::File_system *_vfs = nullptr;
+
 
 BaseError::BaseError(const FormatOrString & fs, unsigned int status)
     : status(status)
@@ -53,32 +45,28 @@ SysError::SysError(const FormatOrString & fs)
 
 string getEnv(const string & key, const string & def)
 {
-    char * value = getenv(key.c_str());
-    return value ? string(value) : def;
+       using namespace Genode;
+
+       try {
+               Xml_node::Attribute attr =
+                       Genode::config()->xml_node().attribute(key.c_str());
+               {
+                       char value[256];
+                       attr.value(value, sizeof(value));
+
+                       PWRN("%s=%s", key.c_str(), value);
+                       return string(value);
+               }
+       } catch (...) { }
+       PWRN("%s=%s", key.c_str(), def.c_str());
+       return def;
 }
 
 
 Path absPath(Path path, Path dir)
 {
-    if (path[0] != '/') {
-        if (dir == "") {
-#ifdef __GNU__
-            /* GNU (aka. GNU/Hurd) doesn't have any limitation on path
-               lengths and doesn't define `PATH_MAX'.  */
-            char *buf = getcwd(NULL, 0);
-            if (buf == NULL)
-#else
-            char buf[PATH_MAX];
-            if (!getcwd(buf, sizeof(buf)))
-#endif
-                throw SysError("cannot get cwd");
-            dir = buf;
-#ifdef __GNU__
-            free(buf);
-#endif
-        }
+    if (path[0] != '/')
         path = dir + "/" + path;
-    }
     return canonPath(path);
 }
 
@@ -174,171 +162,180 @@ bool isInDir(const Path & path, const Path & dir)
 }
 
 
-struct stat lstat(const Path & path)
+Vfs::Directory_service::Stat status(const Path & path)
+{
+    using namespace Vfs;
+
+    Directory_service::Stat stat;
+    switch (_vfs->stat(path.c_str(), stat)) {
+    case Directory_service::STAT_OK: return stat;
+    case Directory_service::STAT_ERR_NO_ENTRY:
+        throw Error(format("getting status of ‘%1%’, STAT_ERR_NO_ENTRY") % path);
+    };
+}
+
+
+void mkdir(const Path & path)
 {
-    struct stat st;
-    if (lstat(path.c_str(), &st))
-        throw SysError(format("getting status of ‘%1%’") % path);
-    return st;
+    if (_vfs->mkdir(path.c_str(), 0) != Vfs::Directory_service::MKDIR_OK)
+        throw Error(format("creating directory ‘%1%’") % path);
 }
 
 
 bool pathExists(const Path & path)
 {
-    int res;
-    struct stat st;
-    res = lstat(path.c_str(), &st);
-    if (!res) return true;
-    if (errno != ENOENT && errno != ENOTDIR)
-        throw SysError(format("getting status of %1%") % path);
-    return false;
+    return _vfs->leaf_path(path.c_str());
 }
 
 
 Path readLink(const Path & path)
 {
-    checkInterrupt();
-    struct stat st = lstat(path);
-    if (!S_ISLNK(st.st_mode))
-        throw Error(format("‘%1%’ is not a symlink") % path);
-    char buf[st.st_size];
-    ssize_t rlsize = readlink(path.c_str(), buf, st.st_size);
-    if (rlsize == -1)
-        throw SysError(format("reading symbolic link ‘%1%’") % path);
-    else if (rlsize > st.st_size)
-        throw Error(format("symbolic link ‘%1%’ size overflow %2% > %3%")
-            % path % rlsize % st.st_size);
-    return string(buf, st.st_size);
+    char buf[Vfs::MAX_PATH_LEN];
+    Vfs::file_size n;
+
+    if (_vfs->readlink(path.c_str(), buf, sizeof(buf), n)
+        != Vfs::Directory_service::READLINK_OK)
+        throw Error(format("reading symbolic link ‘%1%’") % path);
+
+    return string(buf, n);
 }
 
 
 bool isLink(const Path & path)
 {
-    struct stat st = lstat(path);
-    return S_ISLNK(st.st_mode);
+    Vfs::Directory_service::Stat stat = status(path);
+    return S_ISLNK(stat.mode);
 }
 
 
 DirEntries readDirectory(const Path & path)
 {
-    DirEntries entries;
-    entries.reserve(64);
+    char const *path_str = path.c_str();
 
-    AutoCloseDir dir = opendir(path.c_str());
-    if (!dir) throw SysError(format("opening directory ‘%1%’") % path);
+    Vfs::file_size n = _vfs->num_dirent(path_str);
+    DirEntries entries(n);
 
-    struct dirent * dirent;
-    while (errno = 0, dirent = readdir(dir)) { /* sic */
-        checkInterrupt();
-        string name = dirent->d_name;
-        if (name == "." || name == "..") continue;
-        entries.emplace_back(name, dirent->d_ino,
-#ifdef HAVE_STRUCT_DIRENT_D_TYPE
-            dirent->d_type
-#else
-            DT_UNKNOWN
-#endif
-        );
-    }
-    if (errno) throw SysError(format("reading directory ‘%1%’") % path);
+    for (int i = 0; i < n; ++i)
+        if (_vfs->dirent(path_str, i, entries[i]) != Vfs::Directory_service::DIRENT_OK)
+            throw Error(format("reading directory ‘%1%’") % path);
 
     return entries;
 }
 
 
-unsigned char getFileType(const Path & path)
+Dirent_type getFileType(const Path & path)
 {
-    struct stat st = lstat(path);
-    if (S_ISDIR(st.st_mode)) return DT_DIR;
-    if (S_ISLNK(st.st_mode)) return DT_LNK;
-    if (S_ISREG(st.st_mode)) return DT_REG;
-    return DT_UNKNOWN;
+    Vfs::Directory_service::Stat st = status(path);
+    if (st.mode & Vfs::Directory_service::STAT_MODE_SYMLINK)
+        st = status(readLink(path));
+
+    if (S_ISREG(st.mode)) return Dirent_type::DIRENT_TYPE_FILE;
+    if (S_ISDIR(st.mode)) return Dirent_type::DIRENT_TYPE_DIRECTORY;
+    if (S_ISLNK(st.mode)) return Dirent_type::DIRENT_TYPE_SYMLINK;
+    return Dirent_type::DIRENT_TYPE_CHARDEV;
 }
 
 
-string readFile(int fd)
+string readFile(Vfs::Vfs_handle &handle)
 {
-    struct stat st;
-    if (fstat(fd, &st) == -1)
-        throw SysError("statting file");
-
-    unsigned char * buf = new unsigned char[st.st_size];
-    AutoDeleteArray<unsigned char> d(buf);
-    readFull(fd, buf, st.st_size);
-
-    return string((char *) buf, st.st_size);
+	throw Error(format("%1% not implemented") % __func__);
 }
 
 
 string readFile(const Path & path, bool drain)
 {
-    AutoCloseFD fd = open(path.c_str(), O_RDONLY);
-    if (fd == -1)
-        throw SysError(format("opening file ‘%1%’") % path);
-    return drain ? drainFD(fd) : readFile(fd);
+    using namespace Vfs;
+
+    Directory_service::Stat stat = status(path);
+
+    char buf[stat.size];
+    Vfs_handle *handle = nullptr;
+    if (_vfs->open(path.c_str(), Vfs::Directory_service::OPEN_MODE_RDONLY, &handle)
+        != Vfs::Directory_service::OPEN_OK)
+        throw Error(format("open ‘%1%’") % path);
+
+    Vfs_handle::Guard guard(handle);
+
+    file_size n = 0;
+    if (handle->fs().read(handle, buf, sizeof(buf), n)
+        != Vfs::File_io_service::READ_OK)
+        throw Error(format("open ‘%1%’") % path);
+
+    return string(buf, n);
 }
 
 
 void writeFile(const Path & path, const string & s)
 {
-    AutoCloseFD fd = open(path.c_str(), O_WRONLY | O_TRUNC | O_CREAT, 0666);
-    if (fd == -1)
-        throw SysError(format("opening file ‘%1%’") % path);
-    writeFull(fd, s);
+    using namespace Vfs;
+
+    Directory_service::Stat stat = status(path);
+
+    Vfs_handle *handle = nullptr;
+    if (_vfs->open(path.c_str(), Vfs::Directory_service::OPEN_MODE_RDONLY, &handle)
+        != Vfs::Directory_service::OPEN_OK)
+        throw Error(format("opening file ‘%1%’") % path);
+
+    Vfs_handle::Guard guard(handle);
+
+    writeFull(handle, s);
 }
 
 
-string readLine(int fd)
+string readLine(Vfs::Vfs_handle *handle)
 {
+    char buf[1024];
     string s;
+
     while (1) {
-        checkInterrupt();
-        char ch;
-        ssize_t rd = read(fd, &ch, 1);
-        if (rd == -1) {
-            if (errno != EINTR)
-                throw SysError("reading a line");
-        } else if (rd == 0)
-            throw EndOfFile("unexpected EOF reading a line");
-        else {
-            if (ch == '\n') return s;
-            s += ch;
+        Vfs::file_size n = 0;
+        if (handle->fs().read(handle, buf, sizeof(buf), n)
+            != Vfs::File_io_service::READ_OK)
+            throw Error("reading a line");
+
+        for (int i = 0; i < n; ++i) {
+            if (buf[i] == '\n') {
+                handle->seek(i);
+                s.append(buf, i-1);
+                return s;
+            }
         }
+
+        s.append(buf, n);
     }
 }
 
 
-void writeLine(int fd, string s)
+void writeLine(Vfs::Vfs_handle *handle, string s)
 {
     s += '\n';
-    writeFull(fd, s);
+    writeFull(handle, s);
 }
 
 
-static void _deletePath(const Path & path, unsigned long long & bytesFreed)
+void unlink(const Path & path)
 {
-    checkInterrupt();
+    if (_vfs->unlink(path.c_str()) != Vfs::Directory_service::UNLINK_OK)
+        throw Error(format("cannot unlink ‘%1%’") % path);
 
-    printMsg(lvlVomit, format("%1%") % path);
+}
 
-    struct stat st = lstat(path);
 
-    if (!S_ISDIR(st.st_mode) && st.st_nlink == 1)
-        bytesFreed += st.st_blocks * 512;
+static void _deletePath(const Path & path, unsigned long long & bytesFreed)
+{
+    printMsg(lvlVomit, format("%1%") % path);
 
-    if (S_ISDIR(st.st_mode)) {
-        /* Make the directory writable. */
-        if (!(st.st_mode & S_IWUSR)) {
-            if (chmod(path.c_str(), st.st_mode | S_IWUSR) == -1)
-                throw SysError(format("making ‘%1%’ writable") % path);
-        }
+    Vfs::Directory_service::Stat stat = status(path);
+
+    if (!(S_ISDIR(stat.mode)))
+        bytesFreed += stat.size;
 
+    else {
         for (auto & i : readDirectory(path))
             _deletePath(path + "/" + i.name, bytesFreed);
     }
 
-    if (remove(path.c_str()) == -1)
-        throw SysError(format("cannot unlink ‘%1%’") % path);
+    unlink(path);
 }
 
 
@@ -362,60 +359,62 @@ static Path tempName(Path tmpRoot, const Path & prefix, bool includePid,
     int & counter)
 {
     tmpRoot = canonPath(tmpRoot.empty() ? getEnv("TMPDIR", "/tmp") : tmpRoot, true);
-    if (includePid)
-        return (format("%1%/%2%-%3%-%4%") % tmpRoot % prefix % getpid() % counter++).str();
-    else
         return (format("%1%/%2%-%3%") % tmpRoot % prefix % counter++).str();
 }
 
 
 Path createTempDir(const Path & tmpRoot, const Path & prefix,
-    bool includePid, bool useGlobalCounter, mode_t mode)
+    bool includePid, bool useGlobalCounter, unsigned mode)
 {
     static int globalCounter = 0;
     int localCounter = 0;
     int & counter(useGlobalCounter ? globalCounter : localCounter);
 
+    typedef Vfs::Directory_service::Mkdir_result Result;
     while (1) {
         checkInterrupt();
         Path tmpDir = tempName(tmpRoot, prefix, includePid, counter);
-        if (mkdir(tmpDir.c_str(), mode) == 0) {
-            /* Explicitly set the group of the directory.  This is to
-               work around around problems caused by BSD's group
-               ownership semantics (directories inherit the group of
-               the parent).  For instance, the group of /tmp on
-               FreeBSD is "wheel", so all directories created in /tmp
-               will be owned by "wheel"; but if the user is not in
-               "wheel", then "tar" will fail to unpack archives that
-               have the setgid bit set on directories. */
-            if (chown(tmpDir.c_str(), (uid_t) -1, getegid()) != 0)
-                throw SysError(format("setting group of directory ‘%1%’") % tmpDir);
+        switch (_vfs->mkdir(tmpDir.c_str(), mode)) {
+        case Result::MKDIR_OK:
             return tmpDir;
-        }
-        if (errno != EEXIST)
+        case Result::MKDIR_ERR_EXISTS:
+            continue;
+        default:
             throw SysError(format("creating directory ‘%1%’") % tmpDir);
+        }
     }
 }
 
 
 Paths createDirs(const Path & path)
 {
+    using namespace Vfs;
+
     Paths created;
     if (path == "/") return created;
 
-    struct stat st;
-    if (lstat(path.c_str(), &st) == -1) {
+    typedef Vfs::Directory_service::Stat_result Stat_result;
+
+    typedef Vfs::Directory_service::Mkdir_result Mkdir_result;
+    Directory_service::Stat stat;
+    if (_vfs->stat(path.c_str(), stat) == Stat_result::STAT_ERR_NO_ENTRY) {
         created = createDirs(dirOf(path));
-        if (mkdir(path.c_str(), 0777) == -1 && errno != EEXIST)
+        switch (_vfs->mkdir(path.c_str(), 0777)) {
+        case Mkdir_result::MKDIR_OK:
+        case Mkdir_result::MKDIR_ERR_EXISTS:
+            break;
+        default:
             throw SysError(format("creating directory ‘%1%’") % path);
-        st = lstat(path);
+        }
+        stat = status(path);
         created.push_back(path);
-    }
+    };
 
-    if (S_ISLNK(st.st_mode) && stat(path.c_str(), &st) == -1)
+    if (S_ISLNK(stat.mode)
+     && _vfs->stat(readLink(path).c_str(), stat) == Stat_result::STAT_ERR_NO_ENTRY)
         throw SysError(format("statting symlink ‘%1%’") % path);
 
-    if (!S_ISDIR(st.st_mode)) throw Error(format("‘%1%’ is not a directory") % path);
+    if (!S_ISDIR(stat.mode)) throw Error(format("‘%1%’ is not a directory") % path);
 
     return created;
 }
@@ -423,8 +422,9 @@ Paths createDirs(const Path & path)
 
 void createSymlink(const Path & target, const Path & link)
 {
-    if (symlink(target.c_str(), link.c_str()))
-        throw SysError(format("creating symlink from ‘%1%’ to ‘%2%’") % link % target);
+    if (_vfs->symlink(target.c_str(), link.c_str())
+        != Vfs::Directory_service::SYMLINK_OK)
+        throw Error(format("creating symlink from ‘%1%’ to ‘%2%’") % link % target);
 }
 
 
@@ -511,7 +511,6 @@ void printMsg_(Verbosity level, const FormatOrString & fs)
     }
 
     string s = (format("%1%%2%\n") % prefix % fs.s).str();
-    if (!isatty(STDERR_FILENO)) s = filterANSIEscapes(s);
     writeToStderr(s);
 }
 
@@ -531,7 +530,7 @@ void writeToStderr(const string & s)
         if (_writeToStderr)
             _writeToStderr((const unsigned char *) s.data(), s.size());
         else
-            writeFull(STDERR_FILENO, s);
+            Genode::printf(s.c_str());
     } catch (SysError & e) {
         /* Ignore failing writes to stderr if we're in an exception
            handler, otherwise throw an exception.  We need to ignore
@@ -546,58 +545,48 @@ void writeToStderr(const string & s)
 void (*_writeToStderr) (const unsigned char * buf, size_t count) = 0;
 
 
-void readFull(int fd, unsigned char * buf, size_t count)
+void readFull(Vfs::Vfs_handle *handle, unsigned char * buf, size_t count)
 {
+    using namespace Vfs;
+
+    file_size n = 0;
     while (count) {
-        checkInterrupt();
-        ssize_t res = read(fd, (char *) buf, count);
-        if (res == -1) {
-            if (errno == EINTR) continue;
-            throw SysError("reading from file");
-        }
-        if (res == 0) throw EndOfFile("unexpected end-of-file");
-        count -= res;
-        buf += res;
+        if (handle->fs().read(handle, (char*)buf, count, n) != File_io_service::READ_OK)
+            throw Error("reading from file");
+
+        count -= n;
+        buf += n;
+        if (n == 0) throw EndOfFile("unexpected end-of-file");
+        handle->seek(n);
     }
 }
 
 
-void writeFull(int fd, const unsigned char * buf, size_t count)
+void writeFull(Vfs::Vfs_handle *handle, const unsigned char * buf, size_t count)
 {
+    using namespace Vfs;
+
+    file_size n = 0;
     while (count) {
-        checkInterrupt();
-        ssize_t res = write(fd, (char *) buf, count);
-        if (res == -1) {
-            if (errno == EINTR) continue;
-            throw SysError("writing to file");
-        }
-        count -= res;
-        buf += res;
+        if (handle->fs().write(handle, (char *)buf, count, n) != File_io_service::WRITE_OK)
+            throw Error("writing to file");
+
+        count -= n;
+        buf += n;
+        handle->seek(n);
     }
 }
 
 
-void writeFull(int fd, const string & s)
+void writeFull(Vfs::Vfs_handle *handle, const string & s)
 {
-    writeFull(fd, (const unsigned char *) s.data(), s.size());
+    writeFull(handle, (const unsigned char *) s.data(), s.size());
 }
 
 
 string drainFD(int fd)
 {
-    string result;
-    unsigned char buffer[4096];
-    while (1) {
-        checkInterrupt();
-        ssize_t rd = read(fd, buffer, sizeof buffer);
-        if (rd == -1) {
-            if (errno != EINTR)
-                throw SysError("reading from file");
-        }
-        else if (rd == 0) break;
-        else result.append((char *) buffer, rd);
-    }
-    return result;
+    throw Error(format("%1% not implemented") % __func__);
 }
 
 
@@ -644,20 +633,20 @@ void AutoDelete::reset(const Path & p, bool recursive) {
 
 //////////////////////////////////////////////////////////////////////
 
-
-AutoCloseFD::AutoCloseFD()
+AutoCloseHandle::AutoCloseHandle(const Path & path, unsigned mode)
 {
-    fd = -1;
+    if (_vfs->open(path.c_str(), mode, &_handle) != Vfs::Directory_service::Open_result::OPEN_OK)
+        throw SysError(format("opening file ‘%1%’") % path);
 }
 
 
-AutoCloseFD::AutoCloseFD(int fd)
+AutoCloseHandle::AutoCloseHandle(Vfs::Vfs_handle *handle)
 {
-    this->fd = fd;
+    _handle = handle;
 }
 
 
-AutoCloseFD::AutoCloseFD(const AutoCloseFD & fd)
+AutoCloseHandle::AutoCloseHandle(const AutoCloseHandle & acd)
 {
     /* Copying an AutoCloseFD isn't allowed (who should get to close
        it?).  But as an edge case, allow copying of closed
@@ -665,302 +654,62 @@ AutoCloseFD::AutoCloseFD(const AutoCloseFD & fd)
        involving copy constructor use on default object values in STL
        containers (like when you do `map[value]' where value isn't in
        the map yet). */
-    this->fd = fd.fd;
-    if (this->fd != -1) abort();
-}
-
-
-AutoCloseFD::~AutoCloseFD()
-{
-    try {
-        close();
-    } catch (...) {
-        ignoreException();
-    }
+    _handle = acd._handle;
 }
 
 
-void AutoCloseFD::operator =(int fd)
+AutoCloseHandle::~AutoCloseHandle()
 {
-    if (this->fd != fd) close();
-    this->fd = fd;
+    if (_handle)
+        try { Vfs::Vfs_handle::Guard guard(_handle); }
+        catch (...) { ignoreException(); }
 }
 
 
-AutoCloseFD::operator int() const
+void AutoCloseHandle::operator =(Vfs::Vfs_handle *handle)
 {
-    return fd;
+    if (this->_handle != handle) close();
+    this->_handle = handle;
 }
 
 
-void AutoCloseFD::close()
+void AutoCloseHandle::close()
 {
-    if (fd != -1) {
-        if (::close(fd) == -1)
-            /* This should never happen. */
-            throw SysError(format("closing file descriptor %1%") % fd);
-        fd = -1;
-    }
+    if (_handle) {
+        { Vfs::Vfs_handle::Guard guard(_handle); }
+        _handle = nullptr;
+   }
 }
 
 
-bool AutoCloseFD::isOpen()
+bool AutoCloseHandle::isOpen()
 {
-    return fd != -1;
+    return _handle;
 }
 
 
 /* Pass responsibility for closing this fd to the caller. */
-int AutoCloseFD::borrow()
+Vfs::Vfs_handle *AutoCloseHandle::borrow()
 {
-    int oldFD = fd;
-    fd = -1;
-    return oldFD;
+    Vfs::Vfs_handle *handle = _handle;
+    _handle = nullptr;
+    return handle;
 }
 
 
-void Pipe::create()
+Vfs::file_size AutoCloseHandle::read(unsigned char *dst, Vfs::file_size count)
 {
-    int fds[2];
-    if (pipe(fds) != 0) throw SysError("creating pipe");
-    readSide = fds[0];
-    writeSide = fds[1];
-    closeOnExec(readSide);
-    closeOnExec(writeSide);
+    Vfs::file_size out;
+    if (_handle->fs().read(_handle, (char *)dst, count, out) != Vfs::File_io_service::Read_result::READ_OK)
+        return -1;
+    _handle->advance_seek(out);
+    return out;
 }
 
 
-
 //////////////////////////////////////////////////////////////////////
 
 
-AutoCloseDir::AutoCloseDir()
-{
-    dir = 0;
-}
-
-
-AutoCloseDir::AutoCloseDir(DIR * dir)
-{
-    this->dir = dir;
-}
-
-
-AutoCloseDir::~AutoCloseDir()
-{
-    close();
-}
-
-
-void AutoCloseDir::operator =(DIR * dir)
-{
-    this->dir = dir;
-}
-
-
-AutoCloseDir::operator DIR *()
-{
-    return dir;
-}
-
-
-void AutoCloseDir::close()
-{
-    if (dir) {
-        closedir(dir);
-        dir = 0;
-    }
-}
-
-
-//////////////////////////////////////////////////////////////////////
-
-
-Pid::Pid()
-    : pid(-1), separatePG(false), killSignal(SIGKILL)
-{
-}
-
-
-Pid::Pid(pid_t pid)
-    : pid(pid), separatePG(false), killSignal(SIGKILL)
-{
-}
-
-
-Pid::~Pid()
-{
-    kill();
-}
-
-
-void Pid::operator =(pid_t pid)
-{
-    if (this->pid != pid) kill();
-    this->pid = pid;
-    killSignal = SIGKILL; // reset signal to default
-}
-
-
-Pid::operator pid_t()
-{
-    return pid;
-}
-
-
-void Pid::kill(bool quiet)
-{
-    if (pid == -1 || pid == 0) return;
-
-    if (!quiet)
-        printMsg(lvlError, format("killing process %1%") % pid);
-
-    /* Send the requested signal to the child.  If it has its own
-       process group, send the signal to every process in the child
-       process group (which hopefully includes *all* its children). */
-    if (::kill(separatePG ? -pid : pid, killSignal) != 0)
-        printMsg(lvlError, (SysError(format("killing process %1%") % pid).msg()));
-
-    /* Wait until the child dies, disregarding the exit status. */
-    int status;
-    while (waitpid(pid, &status, 0) == -1) {
-        checkInterrupt();
-        if (errno != EINTR) {
-            printMsg(lvlError,
-                (SysError(format("waiting for process %1%") % pid).msg()));
-            break;
-        }
-    }
-
-    pid = -1;
-}
-
-
-int Pid::wait(bool block)
-{
-    assert(pid != -1);
-    while (1) {
-        int status;
-        int res = waitpid(pid, &status, block ? 0 : WNOHANG);
-        if (res == pid) {
-            pid = -1;
-            return status;
-        }
-        if (res == 0 && !block) return -1;
-        if (errno != EINTR)
-            throw SysError("cannot get child exit status");
-        checkInterrupt();
-    }
-}
-
-
-void Pid::setSeparatePG(bool separatePG)
-{
-    this->separatePG = separatePG;
-}
-
-
-void Pid::setKillSignal(int signal)
-{
-    this->killSignal = signal;
-}
-
-
-void killUser(uid_t uid)
-{
-    debug(format("killing all processes running under uid ‘%1%’") % uid);
-
-    assert(uid != 0); /* just to be safe... */
-
-    /* The system call kill(-1, sig) sends the signal `sig' to all
-       users to which the current process can send signals.  So we
-       fork a process, switch to uid, and send a mass kill. */
-
-    ProcessOptions options;
-    options.allowVfork = false;
-
-    Pid pid = startProcess([&]() {
-
-        if (setuid(uid) == -1)
-            throw SysError("setting uid");
-
-        while (true) {
-#ifdef __APPLE__
-            /* OSX's kill syscall takes a third parameter that, among
-               other things, determines if kill(-1, signo) affects the
-               calling process. In the OSX libc, it's set to true,
-               which means "follow POSIX", which we don't want here
-                 */
-            if (syscall(SYS_kill, -1, SIGKILL, false) == 0) break;
-#else
-            if (kill(-1, SIGKILL) == 0) break;
-#endif
-            if (errno == ESRCH) break; /* no more processes */
-            if (errno != EINTR)
-                throw SysError(format("cannot kill processes for uid ‘%1%’") % uid);
-        }
-
-        _exit(0);
-    }, options);
-
-    int status = pid.wait(true);
-    if (status != 0)
-        throw Error(format("cannot kill processes for uid ‘%1%’: %2%") % uid % statusToString(status));
-
-    /* !!! We should really do some check to make sure that there are
-       no processes left running under `uid', but there is no portable
-       way to do so (I think).  The most reliable way may be `ps -eo
-       uid | grep -q $uid'. */
-}
-
-
-//////////////////////////////////////////////////////////////////////
-
-
-/* Wrapper around vfork to prevent the child process from clobbering
-   the caller's stack frame in the parent. */
-static pid_t doFork(bool allowVfork, std::function<void()> fun) __attribute__((noinline));
-static pid_t doFork(bool allowVfork, std::function<void()> fun)
-{
-#ifdef __linux__
-    pid_t pid = allowVfork ? vfork() : fork();
-#else
-    pid_t pid = fork();
-#endif
-    if (pid != 0) return pid;
-    fun();
-    abort();
-}
-
-
-pid_t startProcess(std::function<void()> fun, const ProcessOptions & options)
-{
-    auto wrapper = [&]() {
-        if (!options.allowVfork) _writeToStderr = 0;
-        try {
-#if __linux__
-            if (options.dieWithParent && prctl(PR_SET_PDEATHSIG, SIGKILL) == -1)
-                throw SysError("setting death signal");
-#endif
-            restoreAffinity();
-            fun();
-        } catch (std::exception & e) {
-            try {
-                std::cerr << options.errorPrefix << e.what() << "\n";
-            } catch (...) { }
-        } catch (...) { }
-        if (options.runExitHandlers)
-            exit(1);
-        else
-            _exit(1);
-    };
-
-    pid_t pid = doFork(options.allowVfork, wrapper);
-    if (pid == -1) throw SysError("unable to fork");
-
-    return pid;
-}
-
 
 std::vector<char *> stringsToCharPtrs(const Strings & ss)
 {
@@ -971,101 +720,13 @@ std::vector<char *> stringsToCharPtrs(const Strings & ss)
 }
 
 
-string runProgram(Path program, bool searchPath, const Strings & args,
-    const string & input)
-{
-    checkInterrupt();
-
-    /* Create a pipe. */
-    Pipe out, in;
-    out.create();
-    if (!input.empty()) in.create();
-
-    /* Fork. */
-    Pid pid = startProcess([&]() {
-        if (dup2(out.writeSide, STDOUT_FILENO) == -1)
-            throw SysError("dupping stdout");
-        if (!input.empty()) {
-            if (dup2(in.readSide, STDIN_FILENO) == -1)
-                throw SysError("dupping stdin");
-        }
-
-        Strings args_(args);
-        args_.push_front(program);
-
-        if (searchPath)
-            execvp(program.c_str(), stringsToCharPtrs(args_).data());
-        else
-            execv(program.c_str(), stringsToCharPtrs(args_).data());
-
-        throw SysError(format("executing ‘%1%’") % program);
-    });
-
-    out.writeSide.close();
-
-    /* FIXME: This can deadlock if the input is too long. */
-    if (!input.empty()) {
-        in.readSide.close();
-        writeFull(in.writeSide, input);
-        in.writeSide.close();
-    }
-
-    string result = drainFD(out.readSide);
-
-    /* Wait for the child to finish. */
-    int status = pid.wait(true);
-    if (!statusOk(status))
-        throw ExecError(format("program ‘%1%’ %2%")
-            % program % statusToString(status));
-
-    return result;
-}
-
-
-void closeMostFDs(const set<int> & exceptions)
-{
-    int maxFD = 0;
-    maxFD = sysconf(_SC_OPEN_MAX);
-    for (int fd = 0; fd < maxFD; ++fd)
-        if (fd != STDIN_FILENO && fd != STDOUT_FILENO && fd != STDERR_FILENO
-            && exceptions.find(fd) == exceptions.end())
-            close(fd); /* ignore result */
-}
-
-
-void closeOnExec(int fd)
-{
-    int prev;
-    if ((prev = fcntl(fd, F_GETFD, 0)) == -1 ||
-        fcntl(fd, F_SETFD, prev | FD_CLOEXEC) == -1)
-        throw SysError("setting close-on-exec flag");
-}
-
-
-void restoreSIGPIPE()
-{
-    struct sigaction act;
-    act.sa_handler = SIG_DFL;
-    act.sa_flags = 0;
-    sigemptyset(&act.sa_mask);
-    if (sigaction(SIGPIPE, &act, 0)) throw SysError("resetting SIGPIPE");
-}
-
-
 //////////////////////////////////////////////////////////////////////
 
 
-volatile sig_atomic_t _isInterrupted = 0;
+bool _isInterrupted = false;
 
 void _interrupted()
 {
-    /* Block user interrupts while an exception is being handled.
-       Throwing an exception while another exception is being handled
-       kills the program! */
-    if (!std::uncaught_exception()) {
-        _isInterrupted = 0;
-        throw Interrupted("interrupted by the user");
-    }
 }
 
 
@@ -1144,32 +805,6 @@ string replaceStrings(const std::string & s,
 }
 
 
-string statusToString(int status)
-{
-    if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {
-        if (WIFEXITED(status))
-            return (format("failed with exit code %1%") % WEXITSTATUS(status)).str();
-        else if (WIFSIGNALED(status)) {
-            int sig = WTERMSIG(status);
-#if HAVE_STRSIGNAL
-            const char * description = strsignal(sig);
-            return (format("failed due to signal %1% (%2%)") % sig % description).str();
-#else
-            return (format("failed due to signal %1%") % sig).str();
-#endif
-        }
-        else
-            return "died abnormally";
-    } else return "succeeded";
-}
-
-
-bool statusOk(int status)
-{
-    return WIFEXITED(status) && WEXITSTATUS(status) == 0;
-}
-
-
 bool hasSuffix(const string & s, const string & suffix)
 {
     return s.size() >= suffix.size() && string(s, s.size() - suffix.size()) == suffix;
diff --git a/src/libutil/util.hh b/src/libutil/util.hh
index cf93c63..a8cbf31 100644
--- a/src/libutil/util.hh
+++ b/src/libutil/util.hh
@@ -2,14 +2,14 @@
 
 #include "types.hh"
 
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <dirent.h>
-#include <unistd.h>
-#include <signal.h>
 #include <functional>
 
 #include <cstdio>
+#include <vector>
+
+/* Genode includes */
+#include <vfs/file_system.h>
+#include <vfs/vfs_handle.h>
 
 #ifndef HAVE_STRUCT_DIRENT_D_TYPE
 #define DT_UNKNOWN 0
@@ -18,8 +18,20 @@
 #define DT_DIR 3
 #endif
 
+#define S_ISDIR(m) (((m) & 0170000) == 0040000)    /* directory */
+#define S_ISREG(m) (((m) & 0170000) == 0100000)    /* regular file */
+#define S_ISLNK(m) (((m) & 0170000) == 0120000)    /* symbolic link */
+
+#define foreach(it_type, it, collection)                                \
+    for (it_type it = (collection).begin(); it != (collection).end(); ++it)
+
+#define foreach_reverse(it_type, it, collection)                                \
+    for (it_type it = (collection).rbegin(); it != (collection).rend(); ++it)
+
 namespace nix {
 
+extern Vfs::File_system *_vfs;
+
 
 /* Return an environment variable. */
 string getEnv(const string & key, const string & def = "");
@@ -50,7 +62,7 @@ string baseNameOf(const Path & path);
 bool isInDir(const Path & path, const Path & dir);
 
 /* Get status of `path'. */
-struct stat lstat(const Path & path);
+Vfs::Directory_service::Stat status(const Path & path);
 
 /* Return true iff the given path exists. */
 bool pathExists(const Path & path);
@@ -63,33 +75,25 @@ bool isLink(const Path & path);
 
 /* Read the contents of a directory.  The entries `.' and `..' are
    removed. */
-struct DirEntry
-{
-    string name;
-    ino_t ino;
-    unsigned char type; // one of DT_*
-    DirEntry(const string & name, ino_t ino, unsigned char type)
-        : name(name), ino(ino), type(type) { }
-};
-
-typedef vector<DirEntry> DirEntries;
+typedef std::vector<Vfs::Directory_service::Dirent> DirEntries;
 
 DirEntries readDirectory(const Path & path);
 
-unsigned char getFileType(const Path & path);
+typedef Vfs::Directory_service::Dirent_type Dirent_type;
+Dirent_type getFileType(const Path & path);
 
 /* Read the contents of a file into a string. */
-string readFile(int fd);
+string readFile(Vfs::Vfs_handle &handle);
 string readFile(const Path & path, bool drain = false);
 
 /* Write a string to a file. */
 void writeFile(const Path & path, const string & s);
 
 /* Read a line from a file descriptor. */
-string readLine(int fd);
+string readLine(Vfs::Vfs_handle &handle);
 
 /* Write a line to a file descriptor. */
-void writeLine(int fd, string s);
+void writeLine(Vfs::Vfs_handle &handle, string s);
 
 /* Delete a path; i.e., in the case of a directory, it is deleted
    recursively.  Don't use this at home, kids.  The second variant
@@ -100,7 +104,7 @@ void deletePath(const Path & path, unsigned long long & bytesFreed);
 
 /* Create a temporary directory. */
 Path createTempDir(const Path & tmpRoot = "", const Path & prefix = "nix",
-    bool includePid = true, bool useGlobalCounter = true, mode_t mode = 0755);
+    bool includePid = true, bool useGlobalCounter = true, unsigned mode = 0755);
 
 /* Create a directory and all its parents, if necessary.  Returns the
    list of created directories, in order of creation. */
@@ -172,9 +176,10 @@ extern void (*_writeToStderr) (const unsigned char * buf, size_t count);
 
 /* Wrappers arount read()/write() that read/write exactly the
    requested number of bytes. */
-void readFull(int fd, unsigned char * buf, size_t count);
-void writeFull(int fd, const unsigned char * buf, size_t count);
-void writeFull(int fd, const string & s);
+void readFull(Vfs::Vfs_handle *handle, unsigned char * buf, size_t count);
+void writeFull(Vfs::Vfs_handle *handle, const unsigned char * buf, size_t count);
+void writeFull(Vfs::Vfs_handle *handle, const string & s);
+
 
 MakeError(EndOfFile, Error)
 
@@ -183,7 +188,6 @@ MakeError(EndOfFile, Error)
 string drainFD(int fd);
 
 
-
 /* Automatic cleanup of resources. */
 
 
@@ -214,85 +218,23 @@ public:
 };
 
 
-class AutoCloseFD
+class AutoCloseHandle
 {
-    int fd;
+private:
+    Vfs::Vfs_handle *_handle = nullptr;
 public:
-    AutoCloseFD();
-    AutoCloseFD(int fd);
-    AutoCloseFD(const AutoCloseFD & fd);
-    ~AutoCloseFD();
-    void operator =(int fd);
-    operator int() const;
+    AutoCloseHandle(const Path & path, unsigned mode);
+    AutoCloseHandle(Vfs::Vfs_handle *handle);
+    AutoCloseHandle(const AutoCloseHandle & acd);
+    ~AutoCloseHandle();
+    void operator =(Vfs::Vfs_handle *handle);
     void close();
     bool isOpen();
-    int borrow();
+    Vfs::Vfs_handle *borrow();
+    Vfs::file_size read(unsigned char *dst, Vfs::file_size count);
 };
 
 
-class Pipe
-{
-public:
-    AutoCloseFD readSide, writeSide;
-    void create();
-};
-
-
-class AutoCloseDir
-{
-    DIR * dir;
-public:
-    AutoCloseDir();
-    AutoCloseDir(DIR * dir);
-    ~AutoCloseDir();
-    void operator =(DIR * dir);
-    operator DIR *();
-    void close();
-};
-
-
-class Pid
-{
-    pid_t pid;
-    bool separatePG;
-    int killSignal;
-public:
-    Pid();
-    Pid(pid_t pid);
-    ~Pid();
-    void operator =(pid_t pid);
-    operator pid_t();
-    void kill(bool quiet = false);
-    int wait(bool block);
-    void setSeparatePG(bool separatePG);
-    void setKillSignal(int signal);
-};
-
-
-/* Kill all processes running under the specified uid by sending them
-   a SIGKILL. */
-void killUser(uid_t uid);
-
-
-/* Fork a process that runs the given function, and return the child
-   pid to the caller. */
-struct ProcessOptions
-{
-    string errorPrefix;
-    bool dieWithParent;
-    bool runExitHandlers;
-    bool allowVfork;
-    ProcessOptions() : errorPrefix("error: "), dieWithParent(true), runExitHandlers(false), allowVfork(true) { };
-};
-
-pid_t startProcess(std::function<void()> fun, const ProcessOptions & options = ProcessOptions());
-
-
-/* Run a program and return its stdout in a string (i.e., like the
-   shell backtick operator). */
-string runProgram(Path program, bool searchPath = false,
-    const Strings & args = Strings(), const string & input = "");
-
 MakeError(ExecError, Error)
 
 /* Convert a list of strings to a null-terminated vector of char
@@ -314,7 +256,7 @@ void restoreSIGPIPE();
 
 /* User interruption. */
 
-extern volatile sig_atomic_t _isInterrupted;
+extern bool _isInterrupted;
 
 void _interrupted();
 
diff --git a/src/libutil/xml-writer.cc b/src/libutil/xml-writer.cc
index 98bd058..0179400 100644
--- a/src/libutil/xml-writer.cc
+++ b/src/libutil/xml-writer.cc
@@ -73,10 +73,10 @@ void XMLWriter::writeEmptyElement(const string & name,
 
 void XMLWriter::writeAttrs(const XMLAttrs & attrs)
 {
-    for (auto & i : attrs) {
-        output << " " << i.first << "=\"";
-        for (unsigned int j = 0; j < i.second.size(); ++j) {
-            char c = i.second[j];
+    for (XMLAttrs::const_iterator i = attrs.begin(); i != attrs.end(); ++i) {
+        output << " " << i->first << "=\"";
+        for (unsigned int j = 0; j < i->second.size(); ++j) {
+            char c = i->second[j];
             if (c == '"') output << "&quot;";
             else if (c == '<') output << "&lt;";
             else if (c == '>') output << "&gt;";
