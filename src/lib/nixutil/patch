diff --git a/src/libutil/affinity.cc b/src/libutil/affinity.cc
index 3e21f43..cb9a29f 100644
--- a/src/libutil/affinity.cc
+++ b/src/libutil/affinity.cc
@@ -2,10 +2,6 @@
 #include "util.hh"
 #include "affinity.hh"
 
-#if HAVE_SCHED_H
-#include <sched.h>
-#endif
-
 namespace nix {
 
 
diff --git a/src/libutil/archive.cc b/src/libutil/archive.cc
index 9e16e04..96abd8e 100644
--- a/src/libutil/archive.cc
+++ b/src/libutil/archive.cc
@@ -9,12 +9,6 @@
 
 #include <strings.h> // for strcasecmp
 
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <dirent.h>
-#include <fcntl.h>
-
 #include "archive.hh"
 #include "util.hh"
 
@@ -36,22 +30,32 @@ static string caseHackSuffix = "~nix~case~hack~";
 PathFilter defaultPathFilter;
 
 
-static void dumpContents(const Path & path, size_t size,
+static void dumpContents(Vfs_root &vfs, const Path & path, size_t size,
     Sink & sink)
 {
+    using namespace Vfs;
+
     writeString("contents", sink);
     writeLongLong(size, sink);
 
-    AutoCloseFD fd = open(path.c_str(), O_RDONLY);
-    if (fd == -1) throw SysError(format("opening file ‘%1%’") % path);
+    Vfs_handle *handle = nullptr;
+    if (vfs.fs().open(path.c_str(), Directory_service::OPEN_MODE_RDONLY, &handle)
+        != Vfs::Directory_service::OPEN_OK)
+        throw Error(format("opening file ‘%1%’") % path);
+
+    Vfs_handle::Guard guard(handle);
 
     unsigned char buf[65536];
     size_t left = size;
 
     while (left > 0) {
-        size_t n = left > sizeof(buf) ? sizeof(buf) : left;
-        readFull(fd, buf, n);
+        file_size n;
+        if (handle->fs().read(handle, (char *)buf, sizeof(buf), n) != File_io_service::READ_OK)
+            throw Error(format("reading file ‘%1%’") % path);
+
         left -= n;
+        if (left)
+            handle->seek(n);
         sink(buf, n);
     }
 
@@ -59,44 +63,28 @@ static void dumpContents(const Path & path, size_t size,
 }
 
 
-static void dump(const Path & path, Sink & sink, PathFilter & filter)
+static void dump(Vfs_root &vfs, const Path & path, Sink & sink, PathFilter & filter)
 {
-    struct stat st;
-    if (lstat(path.c_str(), &st))
-        throw SysError(format("getting attributes of path ‘%1%’") % path);
+    using namespace Vfs;
+
+    Directory_service::Stat stat = vfs.status(path);
 
     writeString("(", sink);
 
-    if (S_ISREG(st.st_mode)) {
+    if (S_ISREG(stat.mode)) {
         writeString("type", sink);
         writeString("regular", sink);
-        if (st.st_mode & S_IXUSR) {
-            writeString("executable", sink);
-            writeString("", sink);
-        }
-        dumpContents(path, (size_t) st.st_size, sink);
+        dumpContents(vfs, path, (size_t) stat.size, sink);
     }
 
-    else if (S_ISDIR(st.st_mode)) {
+    else if (S_ISDIR(stat.mode)) {
         writeString("type", sink);
         writeString("directory", sink);
 
         /* If we're on a case-insensitive system like Mac OS X, undo
            the case hack applied by restorePath(). */
         std::map<string, string> unhacked;
-        for (auto & i : readDirectory(path))
-            if (useCaseHack) {
-                string name(i.name);
-                size_t pos = i.name.find(caseHackSuffix);
-                if (pos != string::npos) {
-                    printMsg(lvlDebug, format("removing case hack suffix from ‘%1%’") % (path + "/" + i.name));
-                    name.erase(pos);
-                }
-                if (unhacked.find(name) != unhacked.end())
-                    throw Error(format("file name collision in between ‘%1%’ and ‘%2%’")
-                        % (path + "/" + unhacked[name]) % (path + "/" + i.name));
-                unhacked[name] = i.name;
-            } else
+        for (auto & i : vfs.readDirectory(path))
                 unhacked[i.name] = i.name;
 
         for (auto & i : unhacked)
@@ -106,16 +94,16 @@ static void dump(const Path & path, Sink & sink, PathFilter & filter)
                 writeString("name", sink);
                 writeString(i.first, sink);
                 writeString("node", sink);
-                dump(path + "/" + i.second, sink, filter);
+                dump(vfs, path + "/" + i.second, sink, filter);
                 writeString(")", sink);
             }
     }
 
-    else if (S_ISLNK(st.st_mode)) {
+    else if (S_ISLNK(stat.mode)) {
         writeString("type", sink);
         writeString("symlink", sink);
         writeString("target", sink);
-        writeString(readLink(path), sink);
+        writeString(vfs.readLink(path), sink);
     }
 
     else throw Error(format("file ‘%1%’ has an unsupported type") % path);
@@ -124,10 +112,10 @@ static void dump(const Path & path, Sink & sink, PathFilter & filter)
 }
 
 
-void dumpPath(const Path & path, Sink & sink, PathFilter & filter)
+void dumpPath(Vfs_root &vfs, const Path & path, Sink & sink, PathFilter & filter)
 {
     writeString(archiveVersion1, sink);
-    dump(path, sink, filter);
+    dump(vfs, path, sink, filter);
 }
 
 
@@ -158,7 +146,6 @@ static void parseContents(ParseSink & sink, Source & source, const Path & path)
     unsigned char buf[65536];
 
     while (left) {
-        checkInterrupt();
         unsigned int n = sizeof(buf);
         if ((unsigned long long) n > left) n = left;
         source(buf, n);
@@ -179,7 +166,7 @@ struct CaseInsensitiveCompare
 };
 
 
-static void parse(ParseSink & sink, Source & source, const Path & path)
+static void parse(Vfs_root &vfs, ParseSink & sink, Source & source, const Path & path)
 {
     string s;
 
@@ -191,7 +178,6 @@ static void parse(ParseSink & sink, Source & source, const Path & path)
     std::map<Path, int, CaseInsensitiveCompare> names;
 
     while (1) {
-        checkInterrupt();
 
         s = readString(source);
 
@@ -226,11 +212,6 @@ static void parse(ParseSink & sink, Source & source, const Path & path)
             parseContents(sink, source, path);
         }
 
-        else if (s == "executable" && type == tpRegular) {
-            readString(source);
-            sink.isExecutable();
-        }
-
         else if (s == "entry" && type == tpDirectory) {
             string name, prevName;
 
@@ -238,7 +219,6 @@ static void parse(ParseSink & sink, Source & source, const Path & path)
             if (s != "(") throw badArchive("expected open tag");
 
             while (1) {
-                checkInterrupt();
 
                 s = readString(source);
 
@@ -262,7 +242,7 @@ static void parse(ParseSink & sink, Source & source, const Path & path)
                     }
                 } else if (s == "node") {
                     if (s.empty()) throw badArchive("entry name missing");
-                    parse(sink, source, path + "/" + name);
+                    parse(vfs, sink, source, path + "/" + name);
                 } else
                     throw badArchive("unknown field " + s);
             }
@@ -279,7 +259,7 @@ static void parse(ParseSink & sink, Source & source, const Path & path)
 }
 
 
-void parseDump(ParseSink & sink, Source & source)
+void parseDump(Vfs_root &vfs, ParseSink & sink, Source & source)
 {
     string version;
     try {
@@ -290,72 +270,68 @@ void parseDump(ParseSink & sink, Source & source)
     }
     if (version != archiveVersion1)
         throw badArchive("input doesn't look like a Nix archive");
-    parse(sink, source, "");
+    parse(vfs, sink, source, "");
 }
 
 
 struct RestoreSink : ParseSink
 {
     Path dstPath;
-    AutoCloseFD fd;
+    Vfs::Vfs_handle *handle;
 
-    void createDirectory(const Path & path)
+    RestoreSink() : handle(nullptr) { }
+
+    ~RestoreSink()
     {
-        Path p = dstPath + path;
-        if (mkdir(p.c_str(), 0777) == -1)
-            throw SysError(format("creating directory ‘%1%’") % p);
-    };
+        if (handle)
+            destroy(Genode::env()->heap(), handle);
+    }
 
-    void createRegularFile(const Path & path)
+    void createDirectory(Vfs_root &vfs, const Path & path)
     {
         Path p = dstPath + path;
-        fd.close();
-        fd = open(p.c_str(), O_CREAT | O_EXCL | O_WRONLY, 0666);
-        if (fd == -1) throw SysError(format("creating file ‘%1%’") % p);
-    }
+        vfs.mkdir(p);
+    };
 
-    void isExecutable()
+    void createRegularFile(Vfs_root &vfs, const Path & path)
     {
-        struct stat st;
-        if (fstat(fd, &st) == -1)
-            throw SysError("fstat");
-        if (fchmod(fd, st.st_mode | (S_IXUSR | S_IXGRP | S_IXOTH)) == -1)
-            throw SysError("fchmod");
+        using namespace Vfs;
+
+        if (handle)
+            destroy(Genode::env()->heap(), handle);
+
+        Path p = dstPath + path;
+        enum { MODE = Directory_service::OPEN_MODE_WRONLY | Directory_service::OPEN_MODE_CREATE };
+        if (vfs.fs().open(path.c_str(), MODE, &handle) != Directory_service::OPEN_OK)
+            throw Error(format("creating file ‘%1%’") % p);
     }
 
     void preallocateContents(unsigned long long len)
     {
-#if HAVE_POSIX_FALLOCATE
-        if (len) {
-            errno = posix_fallocate(fd, 0, len);
-            /* Note that EINVAL may indicate that the underlying
-               filesystem doesn't support preallocation (e.g. on
-               OpenSolaris).  Since preallocation is just an
-               optimisation, ignore it. */
-            if (errno && errno != EINVAL)
-                throw SysError(format("preallocating file of %1% bytes") % len);
-        }
-#endif
+        if (handle)
+            handle->fs().ftruncate(handle, handle->seek()+Vfs::file_size(len));
     }
 
     void receiveContents(unsigned char * data, unsigned int len)
     {
-        writeFull(fd, data, len);
+        Vfs::file_size n;
+        if (handle->fs().write(handle, (char *)data, len, n) != Vfs::File_io_service::WRITE_OK)
+            throw Error(format("writing file ‘%1%’") % dstPath);
     }
 
-    void createSymlink(const Path & path, const string & target)
+    void createSymlink(Vfs_root &vfs, const Path & path, const string & target)
     {
         Path p = dstPath + path;
-        nix::createSymlink(target, p);
+        vfs.createSymlink(target, p);
     }
 };
 
 
-void restorePath(const Path & path, Source & source)
+void restorePath(Vfs_root &vfs, const Path & path, Source & source)
 {
     RestoreSink sink;
     sink.dstPath = path;
-    parseDump(sink, source);
+    parseDump(vfs, sink, source);
 }
 
 
diff --git a/src/libutil/archive.hh b/src/libutil/archive.hh
index c216e97..e17a700 100644
--- a/src/libutil/archive.hh
+++ b/src/libutil/archive.hh
@@ -2,6 +2,7 @@
 
 #include "types.hh"
 #include "serialise.hh"
+#include "util.hh"
 
 
 namespace nix {
@@ -52,7 +53,7 @@ struct PathFilter
 
 extern PathFilter defaultPathFilter;
 
-void dumpPath(const Path & path, Sink & sink,
+void dumpPath(Vfs_root &vfs, const Path & path, Sink & sink,
     PathFilter & filter = defaultPathFilter);
 
 struct ParseSink
@@ -67,7 +68,7 @@ struct ParseSink
     virtual void createSymlink(const Path & path, const string & target) { };
 };
 
-void parseDump(ParseSink & sink, Source & source);
+void parseDump(Vfs_root &vfs, ParseSink & sink, Source & source);
 
 void restorePath(const Path & path, Source & source);
 
diff --git a/src/libutil/hash.cc b/src/libutil/hash.cc
index 965f3ed..208b98f 100644
--- a/src/libutil/hash.cc
+++ b/src/libutil/hash.cc
@@ -18,10 +18,6 @@ extern "C" {
 #include "archive.hh"
 #include "util.hh"
 
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-
 
 namespace nix {
 
@@ -283,21 +279,30 @@ Hash hashString(HashType ht, const string & s)
 }
 
 
-Hash hashFile(HashType ht, const Path & path)
+Hash hashFile(Vfs_root &vfs, HashType ht, const Path & path)
 {
+    using namespace Vfs;
+
     Ctx ctx;
     Hash hash(ht);
     start(ht, ctx);
 
-    AutoCloseFD fd = open(path.c_str(), O_RDONLY);
-    if (fd == -1) throw SysError(format("opening file ‘%1%’") % path);
+    Vfs_handle *handle = nullptr;
+    if (vfs.fs().open(path.c_str(), Directory_service::OPEN_MODE_RDONLY, &handle)
+        != Vfs::Directory_service::OPEN_OK)
+        throw Error(format("opening file ‘%1%’") % path);
+
+    Vfs_handle::Guard guard(handle);
 
     unsigned char buf[8192];
-    ssize_t n;
-    while ((n = read(fd, buf, sizeof(buf)))) {
-        checkInterrupt();
-        if (n == -1) throw SysError(format("reading file ‘%1%’") % path);
-        update(ht, ctx, buf, n);
+    file_size n = 1;
+    while (n) {
+        if (handle->fs().read(handle, (char *)buf, sizeof(buf), n) != File_io_service::READ_OK)
+            throw Error(format("reading file ‘%1%’") % path);
+        if (n) {
+            update(ht, ctx, buf, n);
+            handle->seek(n);
+        }
     }
     
     finish(ht, ctx, hash.hash);
@@ -343,10 +348,10 @@ HashResult HashSink::currentHash()
 
 
 HashResult hashPath(
-    HashType ht, const Path & path, PathFilter & filter)
+    Vfs_root &vfs, HashType ht, const Path & path, PathFilter & filter)
 {
     HashSink sink(ht);
-    dumpPath(path, sink, filter);
+    dumpPath(vfs, path, sink, filter);
     return sink.finish();
 }
 
diff --git a/src/libutil/hash.hh b/src/libutil/hash.hh
index 2c6f176..0cc327e 100644
--- a/src/libutil/hash.hh
+++ b/src/libutil/hash.hh
@@ -2,6 +2,7 @@
 
 #include "types.hh"
 #include "serialise.hh"
+#include "util.hh"
 
 
 namespace nix {
@@ -70,14 +71,14 @@ bool isHash(const string & s);
 Hash hashString(HashType ht, const string & s);
 
 /* Compute the hash of the given file. */
-Hash hashFile(HashType ht, const Path & path);
+Hash hashFile(Vfs_root &vfs, HashType ht, const Path & path);
 
 /* Compute the hash of the given path.  The hash is defined as
    (essentially) hashString(ht, dumpPath(path)). */
 struct PathFilter;
 extern PathFilter defaultPathFilter;
 typedef std::pair<Hash, unsigned long long> HashResult;
-HashResult hashPath(HashType ht, const Path & path,
+HashResult hashPath(Vfs_root &vfs, HashType ht, const Path & path,
     PathFilter & filter = defaultPathFilter);
 
 /* Compress a hash to the specified number of bytes by cyclically
diff --git a/src/libutil/monitor-fd.hh b/src/libutil/monitor-fd.hh
deleted file mode 100644
index 6f01ccd..0000000
--- a/src/libutil/monitor-fd.hh
+++ /dev/null
@@ -1,43 +0,0 @@
-#pragma once
-
-#include <thread>
-#include <atomic>
-
-#include <cstdlib>
-#include <poll.h>
-#include <sys/types.h>
-#include <unistd.h>
-#include <signal.h>
-
-namespace nix {
-
-
-class MonitorFdHup
-{
-private:
-    std::thread thread;
-
-public:
-    MonitorFdHup(int fd)
-    {
-        thread = std::thread([fd]() {
-            /* Wait indefinitely until a POLLHUP occurs. */
-            struct pollfd fds[1];
-            fds[0].fd = fd;
-            fds[0].events = 0;
-            if (poll(fds, 1, -1) == -1) abort(); // can't happen
-            assert(fds[0].revents & POLLHUP);
-            /* We got POLLHUP, so send an INT signal to the main thread. */
-            kill(getpid(), SIGINT);
-        });
-    };
-
-    ~MonitorFdHup()
-    {
-        pthread_cancel(thread.native_handle());
-        thread.join();
-    }
-};
-
-
-}
diff --git a/src/libutil/regex.hh b/src/libutil/regex.hh
index 53e31f4..8cab7be 100644
--- a/src/libutil/regex.hh
+++ b/src/libutil/regex.hh
@@ -2,7 +2,6 @@
 
 #include "types.hh"
 
-#include <sys/types.h>
 #include <regex.h>
 
 #include <map>
diff --git a/src/libutil/serialise.cc b/src/libutil/serialise.cc
index 9241750..4f47fc1 100644
--- a/src/libutil/serialise.cc
+++ b/src/libutil/serialise.cc
@@ -48,12 +48,6 @@ void BufferedSink::flush()
 }
 
 
-FdSink::~FdSink()
-{
-    try { flush(); } catch (...) { ignoreException(); }
-}
-
-
 size_t threshold = 256 * 1024 * 1024;
 
 static void warnLargeDump()
@@ -62,20 +56,6 @@ static void warnLargeDump()
 }
 
 
-void FdSink::write(const unsigned char * data, size_t len)
-{
-    static bool warned = false;
-    if (warn && !warned) {
-        written += len;
-        if (written > threshold) {
-            warnLargeDump();
-            warned = true;
-        }
-    }
-    writeFull(fd, data, len);
-}
-
-
 void Source::operator () (unsigned char * data, size_t len)
 {
     while (len) {
@@ -112,19 +92,6 @@ bool BufferedSource::hasData()
 }
 
 
-size_t FdSource::readUnbuffered(unsigned char * data, size_t len)
-{
-    ssize_t n;
-    do {
-        checkInterrupt();
-        n = ::read(fd, (char *) data, bufSize);
-    } while (n == -1 && errno == EINTR);
-    if (n == -1) throw SysError("reading from file");
-    if (n == 0) throw EndOfFile("unexpected end-of-file");
-    return n;
-}
-
-
 size_t StringSource::read(unsigned char * data, size_t len)
 {
     if (pos == s.size()) throw EndOfFile("end of string reached");
diff --git a/src/libutil/serialise.hh b/src/libutil/serialise.hh
index 6a6f028..d8a10fd 100644
--- a/src/libutil/serialise.hh
+++ b/src/libutil/serialise.hh
@@ -68,31 +68,6 @@ struct BufferedSource : Source
 };
 
 
-/* A sink that writes data to a file descriptor. */
-struct FdSink : BufferedSink
-{
-    int fd;
-    bool warn;
-    size_t written;
-
-    FdSink() : fd(-1), warn(false), written(0) { }
-    FdSink(int fd) : fd(fd), warn(false), written(0) { }
-    ~FdSink();
-    
-    void write(const unsigned char * data, size_t len);
-};
-
-
-/* A source that reads data from a file descriptor. */
-struct FdSource : BufferedSource
-{
-    int fd;
-    FdSource() : fd(-1) { }
-    FdSource(int fd) : fd(fd) { }
-    size_t readUnbuffered(unsigned char * data, size_t len);
-};
-
-
 /* A sink that writes data to a string. */
 struct StringSink : Sink
 {
diff --git a/src/libutil/types.hh b/src/libutil/types.hh
index 160884e..e3e2ded 100644
--- a/src/libutil/types.hh
+++ b/src/libutil/types.hh
@@ -8,14 +8,8 @@
 
 #include <boost/format.hpp>
 
-/* Before 4.7, gcc's std::exception uses empty throw() specifiers for
- * its (virtual) destructor and what() in c++11 mode, in violation of spec
- */
-#ifdef __GNUC__
-#if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 7)
-#define EXCEPTION_NEEDS_THROW_SPEC
-#endif
-#endif
+/* Genode includes */
+#include <base/printf.h>
 
 
 namespace nix {
@@ -38,27 +32,39 @@ struct FormatOrString
 };
 
 
-/* BaseError should generally not be caught, as it has Interrupted as
-   a subclass. Catch Error instead. */
-class BaseError : public std::exception
+class Error : public std::runtime_error
 {
 protected:
-    string prefix_; // used for location traces etc.
+
+    string prefix_; /* used for location traces etc. */
     string err;
+
 public:
+
     unsigned int status; // exit status
-    BaseError(const FormatOrString & fs, unsigned int status = 1);
-#ifdef EXCEPTION_NEEDS_THROW_SPEC
-    ~BaseError() throw () { };
-    const char * what() const throw () { return err.c_str(); }
-#else
+
+    Error(const FormatOrString & fs, unsigned int status = 1)
+    :
+        std::runtime_error(fs.s),
+        err(fs.s),
+        status(status)
+    {
+        PERR("%s%s", prefix_.c_str(), fs.s.c_str());
+    }
+
     const char * what() const noexcept { return err.c_str(); }
-#endif
+
     const string & msg() const { return err; }
     const string & prefix() const { return prefix_; }
-    BaseError & addPrefix(const FormatOrString & fs);
+
+    Error & addPrefix(const FormatOrString & fs)
+    {
+        prefix_ = fs.s + prefix_;
+        return *this;
+    }
 };
 
+
 #define MakeError(newClass, superClass) \
     class newClass : public superClass                  \
     {                                                   \
@@ -66,15 +72,6 @@ public:
         newClass(const FormatOrString & fs, unsigned int status = 1) : superClass(fs, status) { }; \
     };
 
-MakeError(Error, BaseError)
-
-class SysError : public Error
-{
-public:
-    int errNo;
-    SysError(const FormatOrString & fs);
-};
-
 
 typedef list<string> Strings;
 typedef set<string> StringSet;
diff --git a/src/libutil/util.cc b/src/libutil/util.cc
index dcdb438..a1403d8 100644
--- a/src/libutil/util.cc
+++ b/src/libutil/util.cc
@@ -4,24 +4,15 @@
 #include "affinity.hh"
 
 #include <iostream>
-#include <cerrno>
 #include <cstdio>
 #include <cstdlib>
 #include <sstream>
 #include <cstring>
 
-#include <sys/wait.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <limits.h>
-
-#ifdef __APPLE__
-#include <sys/syscall.h>
-#endif
-
-#ifdef __linux__
-#include <sys/prctl.h>
-#endif
+/* Genode includes. */
+#include <vfs/dir_file_system.h>
+#include <os/config.h>
+#include <base/printf.h>
 
 
 extern char * * environ;
@@ -30,60 +21,61 @@ extern char * * environ;
 namespace nix {
 
 
-BaseError::BaseError(const FormatOrString & fs, unsigned int status)
-    : status(status)
+string getEnv(const string & key, const string & def)
 {
-    err = fs.s;
-}
+	using namespace Genode;
 
+	try {
+		Xml_node::Attribute attr =
+			config()->xml_node().attribute(key.c_str());
+		{
+			char value[256];
+			attr.value(value, sizeof(value));
 
-BaseError & BaseError::addPrefix(const FormatOrString & fs)
-{
-    prefix_ = fs.s + prefix_;
-    return *this;
+			PDBG("%s=%s", key.c_str(), value);
+			return string(value);
+		}
+	} catch (...) { }
+	PDBG("%s=%s", key.c_str(), def.c_str());
+	return def;
 }
 
 
-SysError::SysError(const FormatOrString & fs)
-    : Error(format("%1%: %2%") % fs.s % strerror(errno))
-    , errNo(errno)
+Path dirOf(const Path & path)
 {
+    Path::size_type pos = path.rfind('/');
+    if (pos == string::npos)
+        throw Error(format("invalid file name ‘%1%’") % path);
+    return pos == 0 ? "/" : Path(path, 0, pos);
 }
 
 
-string getEnv(const string & key, const string & def)
+string baseNameOf(const Path & path)
 {
-    char * value = getenv(key.c_str());
-    return value ? string(value) : def;
+    Path::size_type pos = path.rfind('/');
+    if (pos == string::npos)
+        throw Error(format("invalid file name ‘%1%’") % path);
+    return string(path, pos + 1);
 }
 
 
-Path absPath(Path path, Path dir)
+bool isInDir(const Path & path, const Path & dir)
 {
-    if (path[0] != '/') {
-        if (dir == "") {
-#ifdef __GNU__
-            /* GNU (aka. GNU/Hurd) doesn't have any limitation on path
-               lengths and doesn't define `PATH_MAX'.  */
-            char *buf = getcwd(NULL, 0);
-            if (buf == NULL)
-#else
-            char buf[PATH_MAX];
-            if (!getcwd(buf, sizeof(buf)))
-#endif
-                throw SysError("cannot get cwd");
-            dir = buf;
-#ifdef __GNU__
-            free(buf);
-#endif
-        }
-        path = dir + "/" + path;
-    }
-    return canonPath(path);
+    return path[0] == '/'
+        && string(path, 0, dir.size()) == dir
+        && path.size() >= dir.size() + 2
+        && path[dir.size()] == '/';
 }
 
 
-Path canonPath(const Path & path, bool resolveSymlinks)
+Vfs_root::Vfs_root(Vfs::File_system &vfs)
+: _vfs(vfs) { }
+
+
+Vfs::File_system &Vfs_root::fs() { return _vfs; }
+
+
+Path Vfs_root::canonPath(const Path & path, bool resolveSymlinks)
 {
     string s;
 
@@ -138,199 +130,177 @@ Path canonPath(const Path & path, bool resolveSymlinks)
 }
 
 
-Path dirOf(const Path & path)
+Path Vfs_root::absPath(Path path, Path dir)
 {
-    Path::size_type pos = path.rfind('/');
-    if (pos == string::npos)
-        throw Error(format("invalid file name ‘%1%’") % path);
-    return pos == 0 ? "/" : Path(path, 0, pos);
+	if (path[0] != '/')
+		path = dir + "/" + path;
+	return canonPath(path);
 }
 
 
-string baseNameOf(const Path & path)
+Vfs::Directory_service::Stat Vfs_root::status(const Path & path)
 {
-    Path::size_type pos = path.rfind('/');
-    if (pos == string::npos)
-        throw Error(format("invalid file name ‘%1%’") % path);
-    return string(path, pos + 1);
+    using namespace Vfs;
+
+    Directory_service::Stat stat;
+    switch (_vfs.stat(path.c_str(), stat)) {
+    case Directory_service::STAT_OK: return stat;
+    case Directory_service::STAT_ERR_NO_ENTRY:   
+        throw Error(format("getting status of ‘%1%’, STAT_ERR_NO_ENTRY") % path);
+    };
 }
 
 
-bool isInDir(const Path & path, const Path & dir)
+void Vfs_root::mkdir(const Path & path)
 {
-    return path[0] == '/'
-        && string(path, 0, dir.size()) == dir
-        && path.size() >= dir.size() + 2
-        && path[dir.size()] == '/';
+    if (_vfs.mkdir(path.c_str(), 0) != Vfs::Directory_service::MKDIR_OK)
+        throw Error(format("creating directory ‘%1%’") % path);
 }
 
 
-struct stat lstat(const Path & path)
-{
-    struct stat st;
-    if (lstat(path.c_str(), &st))
-        throw SysError(format("getting status of ‘%1%’") % path);
-    return st;
-}
+bool Vfs_root::pathExists(const Path & path) {
+    return _vfs.leaf_path(path.c_str()); }
 
 
-bool pathExists(const Path & path)
+Path Vfs_root::readLink(const Path & path)
 {
-    int res;
-    struct stat st;
-    res = lstat(path.c_str(), &st);
-    if (!res) return true;
-    if (errno != ENOENT && errno != ENOTDIR)
-        throw SysError(format("getting status of %1%") % path);
-    return false;
-}
+    char buf[Vfs::MAX_PATH_LEN];
+    Vfs::file_size n;
 
+    if (_vfs.readlink(path.c_str(), buf, sizeof(buf), n)
+        != Vfs::Directory_service::READLINK_OK)
+        throw Error(format("reading symbolic link ‘%1%’") % path);
 
-Path readLink(const Path & path)
-{
-    checkInterrupt();
-    struct stat st = lstat(path);
-    if (!S_ISLNK(st.st_mode))
-        throw Error(format("‘%1%’ is not a symlink") % path);
-    char buf[st.st_size];
-    if (readlink(path.c_str(), buf, st.st_size) != st.st_size)
-        throw SysError(format("reading symbolic link ‘%1%’") % path);
-    return string(buf, st.st_size);
+    return string(buf, n);
 }
 
 
-bool isLink(const Path & path)
+bool Vfs_root::isLink(const Path & path)
 {
-    struct stat st = lstat(path);
-    return S_ISLNK(st.st_mode);
+    Vfs::Directory_service::Stat stat = status(path);
+    return S_ISLNK(stat.mode);
 }
 
 
-DirEntries readDirectory(const Path & path)
+DirEntries Vfs_root::readDirectory(const Path & path)
 {
-    DirEntries entries;
-    entries.reserve(64);
-
-    AutoCloseDir dir = opendir(path.c_str());
-    if (!dir) throw SysError(format("opening directory ‘%1%’") % path);
-
-    struct dirent * dirent;
-    while (errno = 0, dirent = readdir(dir)) { /* sic */
-        checkInterrupt();
-        string name = dirent->d_name;
-        if (name == "." || name == "..") continue;
-        entries.emplace_back(name, dirent->d_ino, dirent->d_type);
-    }
-    if (errno) throw SysError(format("reading directory ‘%1%’") % path);
+    char const *path_str = path.c_str();
+
+    Vfs::file_size n = _vfs.num_dirent(path_str);
+    DirEntries entries(n);
+
+    for (int i = 0; i < n; ++i)
+        if (_vfs.dirent(path_str, i, entries[i]) != Vfs::Directory_service::DIRENT_OK)
+            throw Error(format("reading directory ‘%1%’") % path);
 
     return entries;
 }
 
 
-unsigned char getFileType(const Path & path)
+string Vfs_root::readFile(const Path & path, bool drain)
 {
-    struct stat st = lstat(path);
-    if (S_ISDIR(st.st_mode)) return DT_DIR;
-    if (S_ISLNK(st.st_mode)) return DT_LNK;
-    if (S_ISREG(st.st_mode)) return DT_REG;
-    return DT_UNKNOWN;
-}
+    using namespace Vfs;
 
+    Directory_service::Stat stat = status(path);
 
-string readFile(int fd)
-{
-    struct stat st;
-    if (fstat(fd, &st) == -1)
-        throw SysError("statting file");
+    char buf[stat.size];
+    Vfs_handle *handle = nullptr;
+    if (_vfs.open(path.c_str(), Vfs::Directory_service::OPEN_MODE_RDONLY, &handle)
+        != Vfs::Directory_service::OPEN_OK)
+        throw Error(format("open ‘%1%’") % path);
+
+    Vfs_handle::Guard guard(handle);
 
-    unsigned char * buf = new unsigned char[st.st_size];
-    AutoDeleteArray<unsigned char> d(buf);
-    readFull(fd, buf, st.st_size);
+    file_size n = 0;
+    if (handle->fs().read(handle, buf, sizeof(buf), n)
+        != Vfs::File_io_service::READ_OK)
+        throw Error(format("open ‘%1%’") % path);
 
-    return string((char *) buf, st.st_size);
+    return string(buf, n);
 }
 
 
-string readFile(const Path & path, bool drain)
+void Vfs_root::writeFile(const Path & path, const string & s)
 {
-    AutoCloseFD fd = open(path.c_str(), O_RDONLY);
-    if (fd == -1)
-        throw SysError(format("opening file ‘%1%’") % path);
-    return drain ? drainFD(fd) : readFile(fd);
-}
+    using namespace Vfs;
 
+    Directory_service::Stat stat = status(path);
 
-void writeFile(const Path & path, const string & s)
-{
-    AutoCloseFD fd = open(path.c_str(), O_WRONLY | O_TRUNC | O_CREAT, 0666);
-    if (fd == -1)
-        throw SysError(format("opening file ‘%1%’") % path);
-    writeFull(fd, s);
+    Vfs_handle *handle = nullptr;
+    if (_vfs.open(path.c_str(), Vfs::Directory_service::OPEN_MODE_RDONLY, &handle)
+        != Vfs::Directory_service::OPEN_OK)
+        throw Error(format("opening file ‘%1%’") % path);
+
+    Vfs_handle::Guard guard(handle);
+
+    writeFull(handle, s);
 }
 
 
-string readLine(int fd)
+string readLine(Vfs::Vfs_handle *handle)
 {
+    char buf[1024];
     string s;
+
     while (1) {
-        checkInterrupt();
-        char ch;
-        ssize_t rd = read(fd, &ch, 1);
-        if (rd == -1) {
-            if (errno != EINTR)
-                throw SysError("reading a line");
-        } else if (rd == 0)
-            throw EndOfFile("unexpected EOF reading a line");
-        else {
-            if (ch == '\n') return s;
-            s += ch;
+        Vfs::file_size n = 0;
+        if (handle->fs().read(handle, buf, sizeof(buf), n)
+            != Vfs::File_io_service::READ_OK)
+            throw Error("reading a line");
+
+        for (int i = 0; i < n; ++i) {
+            if (buf[i] == '\n') {
+                handle->seek(i);
+                s.append(buf, i-1);
+                return s;
+            }
         }
+
+        s.append(buf, n);
     }
 }
 
 
-void writeLine(int fd, string s)
+void writeLine(Vfs::Vfs_handle *handle, string s)
 {
     s += '\n';
-    writeFull(fd, s);
+    writeFull(handle, s);
 }
 
 
-static void _deletePath(const Path & path, unsigned long long & bytesFreed)
+void Vfs_root::unlink(const Path & path)
 {
-    checkInterrupt();
+    if (_vfs.unlink(path.c_str()) != Vfs::Directory_service::UNLINK_OK)
+        throw Error(format("cannot unlink ‘%1%’") % path);
+}
+
 
+void Vfs_root::_deletePath(const Path & path, unsigned long long & bytesFreed)
+{
     printMsg(lvlVomit, format("%1%") % path);
 
-    struct stat st = lstat(path);
+    Vfs::Directory_service::Stat stat = status(path);
 
-    if (!S_ISDIR(st.st_mode) && st.st_nlink == 1)
-        bytesFreed += st.st_blocks * 512;
-
-    if (S_ISDIR(st.st_mode)) {
-        /* Make the directory writable. */
-        if (!(st.st_mode & S_IWUSR)) {
-            if (chmod(path.c_str(), st.st_mode | S_IWUSR) == -1)
-                throw SysError(format("making ‘%1%’ writable") % path);
-        }
+    if (!(S_ISDIR(stat.mode)))
+        bytesFreed += stat.size;
 
+    else {
         for (auto & i : readDirectory(path))
             _deletePath(path + "/" + i.name, bytesFreed);
     }
 
-    if (remove(path.c_str()) == -1)
-        throw SysError(format("cannot unlink ‘%1%’") % path);
+    unlink(path);
 }
 
 
-void deletePath(const Path & path)
+void Vfs_root::deletePath(const Path & path)
 {
     unsigned long long dummy;
     deletePath(path, dummy);
 }
 
 
-void deletePath(const Path & path, unsigned long long & bytesFreed)
+void Vfs_root::deletePath(const Path & path, unsigned long long & bytesFreed)
 {
     startNest(nest, lvlDebug,
         format("recursively deleting path ‘%1%’") % path);
@@ -339,73 +309,11 @@ void deletePath(const Path & path, unsigned long long & bytesFreed)
 }
 
 
-static Path tempName(Path tmpRoot, const Path & prefix, bool includePid,
-    int & counter)
-{
-    tmpRoot = canonPath(tmpRoot.empty() ? getEnv("TMPDIR", "/tmp") : tmpRoot, true);
-    if (includePid)
-        return (format("%1%/%2%-%3%-%4%") % tmpRoot % prefix % getpid() % counter++).str();
-    else
-        return (format("%1%/%2%-%3%") % tmpRoot % prefix % counter++).str();
-}
-
-
-Path createTempDir(const Path & tmpRoot, const Path & prefix,
-    bool includePid, bool useGlobalCounter, mode_t mode)
+void Vfs_root::createSymlink(const Path & target, const Path & link)
 {
-    static int globalCounter = 0;
-    int localCounter = 0;
-    int & counter(useGlobalCounter ? globalCounter : localCounter);
-
-    while (1) {
-        checkInterrupt();
-        Path tmpDir = tempName(tmpRoot, prefix, includePid, counter);
-        if (mkdir(tmpDir.c_str(), mode) == 0) {
-            /* Explicitly set the group of the directory.  This is to
-               work around around problems caused by BSD's group
-               ownership semantics (directories inherit the group of
-               the parent).  For instance, the group of /tmp on
-               FreeBSD is "wheel", so all directories created in /tmp
-               will be owned by "wheel"; but if the user is not in
-               "wheel", then "tar" will fail to unpack archives that
-               have the setgid bit set on directories. */
-            if (chown(tmpDir.c_str(), (uid_t) -1, getegid()) != 0)
-                throw SysError(format("setting group of directory ‘%1%’") % tmpDir);
-            return tmpDir;
-        }
-        if (errno != EEXIST)
-            throw SysError(format("creating directory ‘%1%’") % tmpDir);
-    }
-}
-
-
-Paths createDirs(const Path & path)
-{
-    Paths created;
-    if (path == "/") return created;
-
-    struct stat st;
-    if (lstat(path.c_str(), &st) == -1) {
-        created = createDirs(dirOf(path));
-        if (mkdir(path.c_str(), 0777) == -1 && errno != EEXIST)
-            throw SysError(format("creating directory ‘%1%’") % path);
-        st = lstat(path);
-        created.push_back(path);
-    }
-
-    if (S_ISLNK(st.st_mode) && stat(path.c_str(), &st) == -1)
-        throw SysError(format("statting symlink ‘%1%’") % path);
-
-    if (!S_ISDIR(st.st_mode)) throw Error(format("‘%1%’ is not a directory") % path);
-
-    return created;
-}
-
-
-void createSymlink(const Path & target, const Path & link)
-{
-    if (symlink(target.c_str(), link.c_str()))
-        throw SysError(format("creating symlink from ‘%1%’ to ‘%2%’") % link % target);
+    if (_vfs.symlink(target.c_str(), link.c_str())
+        != Vfs::Directory_service::SYMLINK_OK)
+        throw Error(format("creating symlink from ‘%1%’ to ‘%2%’") % link % target);
 }
 
 
@@ -460,17 +368,15 @@ void Nest::close()
 
 void printMsg_(Verbosity level, const FormatOrString & fs)
 {
-    checkInterrupt();
-    if (level > verbosity) return;
-    string prefix;
-    if (logType == ltPretty)
-        for (int i = 0; i < nestingLevel; i++)
-            prefix += "|   ";
-    else if (logType == ltEscapes && level != lvlInfo)
-        prefix = "\033[" + escVerbosity(level) + "s";
-    string s = (format("%1%%2%\n") % prefix % fs.s).str();
-    if (!isatty(STDERR_FILENO)) s = filterANSIEscapes(s);
-    writeToStderr(s);
+	if (level > verbosity) return;
+	string prefix;
+	if (logType == ltPretty)
+		for (int i = 0; i < nestingLevel; i++)
+			prefix += "|   ";
+	else if (logType == ltEscapes && level != lvlInfo)
+		prefix = "\033[" + escVerbosity(level) + "s";
+
+	Genode::printf("%s%s\n", prefix.c_str(), fs.s.c_str());
 }
 
 
@@ -483,87 +389,54 @@ void warnOnce(bool & haveWarned, const FormatOrString & fs)
 }
 
 
-void writeToStderr(const string & s)
-{
-    try {
-        if (_writeToStderr)
-            _writeToStderr((const unsigned char *) s.data(), s.size());
-        else
-            writeFull(STDERR_FILENO, s);
-    } catch (SysError & e) {
-        /* Ignore failing writes to stderr if we're in an exception
-           handler, otherwise throw an exception.  We need to ignore
-           write errors in exception handlers to ensure that cleanup
-           code runs to completion if the other side of stderr has
-           been closed unexpectedly. */
-        if (!std::uncaught_exception()) throw;
-    }
-}
-
-
-void (*_writeToStderr) (const unsigned char * buf, size_t count) = 0;
+void writeToStderr(const string & s) {
+	printf(s.c_str()); }
 
 
-void readFull(int fd, unsigned char * buf, size_t count)
+void readFull(Vfs::Vfs_handle *handle, unsigned char * buf, size_t count)
 {
+    using namespace Vfs;
+
+    file_size n = 0;
     while (count) {
-        checkInterrupt();
-        ssize_t res = read(fd, (char *) buf, count);
-        if (res == -1) {
-            if (errno == EINTR) continue;
-            throw SysError("reading from file");
-        }
-        if (res == 0) throw EndOfFile("unexpected end-of-file");
-        count -= res;
-        buf += res;
+        if (handle->fs().read(handle, (char*)buf, count, n) != File_io_service::READ_OK)
+            throw Error("reading from file");
+
+        count -= n;
+        buf += n;
+        if (n == 0) throw EndOfFile("unexpected end-of-file");
+        handle->seek(n);
     }
 }
 
 
-void writeFull(int fd, const unsigned char * buf, size_t count)
+void writeFull(Vfs::Vfs_handle *handle, const unsigned char * buf, size_t count)
 {
-    while (count) {
-        checkInterrupt();
-        ssize_t res = write(fd, (char *) buf, count);
-        if (res == -1) {
-            if (errno == EINTR) continue;
-            throw SysError("writing to file");
-        }
-        count -= res;
-        buf += res;
-    }
-}
+    using namespace Vfs;
 
+    file_size n = 0;
+    while (count) {
+        if (handle->fs().write(handle, (char *)buf, count, n) != File_io_service::WRITE_OK)
+            throw Error("writing to file");
 
-void writeFull(int fd, const string & s)
-{
-    writeFull(fd, (const unsigned char *) s.data(), s.size());
+        count -= n;
+        buf += n;
+        handle->seek(n);
+    }
 }
 
 
-string drainFD(int fd)
+void writeFull(Vfs::Vfs_handle *handle, const string & s)
 {
-    string result;
-    unsigned char buffer[4096];
-    while (1) {
-        checkInterrupt();
-        ssize_t rd = read(fd, buffer, sizeof buffer);
-        if (rd == -1) {
-            if (errno != EINTR)
-                throw SysError("reading from file");
-        }
-        else if (rd == 0) break;
-        else result.append((char *) buffer, rd);
-    }
-    return result;
+    writeFull(handle, (const unsigned char *) s.data(), s.size());
 }
 
 
-
 //////////////////////////////////////////////////////////////////////
 
 
-AutoDelete::AutoDelete(const string & p, bool recursive) : path(p)
+AutoDelete::AutoDelete(Vfs_root &vfs_root, const string & p, bool recursive)
+: vfs(vfs_root), path(p)
 {
     del = true;
     this->recursive = recursive;
@@ -574,11 +447,9 @@ AutoDelete::~AutoDelete()
     try {
         if (del) {
             if (recursive)
-                deletePath(path);
-            else {
-                if (remove(path.c_str()) == -1)
-                    throw SysError(format("cannot unlink ‘%1%’") % path);
-            }
+                vfs.deletePath(path);
+            else
+                vfs.unlink(path);
         }
     } catch (...) {
         ignoreException();
@@ -591,327 +462,9 @@ void AutoDelete::cancel()
 }
 
 
-
-//////////////////////////////////////////////////////////////////////
-
-
-AutoCloseFD::AutoCloseFD()
-{
-    fd = -1;
-}
-
-
-AutoCloseFD::AutoCloseFD(int fd)
-{
-    this->fd = fd;
-}
-
-
-AutoCloseFD::AutoCloseFD(const AutoCloseFD & fd)
-{
-    /* Copying an AutoCloseFD isn't allowed (who should get to close
-       it?).  But as an edge case, allow copying of closed
-       AutoCloseFDs.  This is necessary due to tiresome reasons
-       involving copy constructor use on default object values in STL
-       containers (like when you do `map[value]' where value isn't in
-       the map yet). */
-    this->fd = fd.fd;
-    if (this->fd != -1) abort();
-}
-
-
-AutoCloseFD::~AutoCloseFD()
-{
-    try {
-        close();
-    } catch (...) {
-        ignoreException();
-    }
-}
-
-
-void AutoCloseFD::operator =(int fd)
-{
-    if (this->fd != fd) close();
-    this->fd = fd;
-}
-
-
-AutoCloseFD::operator int() const
-{
-    return fd;
-}
-
-
-void AutoCloseFD::close()
-{
-    if (fd != -1) {
-        if (::close(fd) == -1)
-            /* This should never happen. */
-            throw SysError(format("closing file descriptor %1%") % fd);
-        fd = -1;
-    }
-}
-
-
-bool AutoCloseFD::isOpen()
-{
-    return fd != -1;
-}
-
-
-/* Pass responsibility for closing this fd to the caller. */
-int AutoCloseFD::borrow()
-{
-    int oldFD = fd;
-    fd = -1;
-    return oldFD;
-}
-
-
-void Pipe::create()
-{
-    int fds[2];
-    if (pipe(fds) != 0) throw SysError("creating pipe");
-    readSide = fds[0];
-    writeSide = fds[1];
-    closeOnExec(readSide);
-    closeOnExec(writeSide);
-}
-
-
-
-//////////////////////////////////////////////////////////////////////
-
-
-AutoCloseDir::AutoCloseDir()
-{
-    dir = 0;
-}
-
-
-AutoCloseDir::AutoCloseDir(DIR * dir)
-{
-    this->dir = dir;
-}
-
-
-AutoCloseDir::~AutoCloseDir()
-{
-    close();
-}
-
-
-void AutoCloseDir::operator =(DIR * dir)
-{
-    this->dir = dir;
-}
-
-
-AutoCloseDir::operator DIR *()
-{
-    return dir;
-}
-
-
-void AutoCloseDir::close()
-{
-    if (dir) {
-        closedir(dir);
-        dir = 0;
-    }
-}
-
-
 //////////////////////////////////////////////////////////////////////
 
 
-Pid::Pid()
-    : pid(-1), separatePG(false), killSignal(SIGKILL)
-{
-}
-
-
-Pid::Pid(pid_t pid)
-    : pid(pid), separatePG(false), killSignal(SIGKILL)
-{
-}
-
-
-Pid::~Pid()
-{
-    kill();
-}
-
-
-void Pid::operator =(pid_t pid)
-{
-    if (this->pid != pid) kill();
-    this->pid = pid;
-    killSignal = SIGKILL; // reset signal to default
-}
-
-
-Pid::operator pid_t()
-{
-    return pid;
-}
-
-
-void Pid::kill(bool quiet)
-{
-    if (pid == -1 || pid == 0) return;
-
-    if (!quiet)
-        printMsg(lvlError, format("killing process %1%") % pid);
-
-    /* Send the requested signal to the child.  If it has its own
-       process group, send the signal to every process in the child
-       process group (which hopefully includes *all* its children). */
-    if (::kill(separatePG ? -pid : pid, killSignal) != 0)
-        printMsg(lvlError, (SysError(format("killing process %1%") % pid).msg()));
-
-    /* Wait until the child dies, disregarding the exit status. */
-    int status;
-    while (waitpid(pid, &status, 0) == -1) {
-        checkInterrupt();
-        if (errno != EINTR) {
-            printMsg(lvlError,
-                (SysError(format("waiting for process %1%") % pid).msg()));
-            break;
-        }
-    }
-
-    pid = -1;
-}
-
-
-int Pid::wait(bool block)
-{
-    assert(pid != -1);
-    while (1) {
-        int status;
-        int res = waitpid(pid, &status, block ? 0 : WNOHANG);
-        if (res == pid) {
-            pid = -1;
-            return status;
-        }
-        if (res == 0 && !block) return -1;
-        if (errno != EINTR)
-            throw SysError("cannot get child exit status");
-        checkInterrupt();
-    }
-}
-
-
-void Pid::setSeparatePG(bool separatePG)
-{
-    this->separatePG = separatePG;
-}
-
-
-void Pid::setKillSignal(int signal)
-{
-    this->killSignal = signal;
-}
-
-
-void killUser(uid_t uid)
-{
-    debug(format("killing all processes running under uid ‘%1%’") % uid);
-
-    assert(uid != 0); /* just to be safe... */
-
-    /* The system call kill(-1, sig) sends the signal `sig' to all
-       users to which the current process can send signals.  So we
-       fork a process, switch to uid, and send a mass kill. */
-
-    ProcessOptions options;
-    options.allowVfork = false;
-
-    Pid pid = startProcess([&]() {
-
-        if (setuid(uid) == -1)
-            throw SysError("setting uid");
-
-        while (true) {
-#ifdef __APPLE__
-            /* OSX's kill syscall takes a third parameter that, among
-               other things, determines if kill(-1, signo) affects the
-               calling process. In the OSX libc, it's set to true,
-               which means "follow POSIX", which we don't want here
-                 */
-            if (syscall(SYS_kill, -1, SIGKILL, false) == 0) break;
-#else
-            if (kill(-1, SIGKILL) == 0) break;
-#endif
-            if (errno == ESRCH) break; /* no more processes */
-            if (errno != EINTR)
-                throw SysError(format("cannot kill processes for uid ‘%1%’") % uid);
-        }
-
-        _exit(0);
-    }, options);
-
-    int status = pid.wait(true);
-    if (status != 0)
-        throw Error(format("cannot kill processes for uid ‘%1%’: %2%") % uid % statusToString(status));
-
-    /* !!! We should really do some check to make sure that there are
-       no processes left running under `uid', but there is no portable
-       way to do so (I think).  The most reliable way may be `ps -eo
-       uid | grep -q $uid'. */
-}
-
-
-//////////////////////////////////////////////////////////////////////
-
-
-/* Wrapper around vfork to prevent the child process from clobbering
-   the caller's stack frame in the parent. */
-static pid_t doFork(bool allowVfork, std::function<void()> fun) __attribute__((noinline));
-static pid_t doFork(bool allowVfork, std::function<void()> fun)
-{
-#ifdef __linux__
-    pid_t pid = allowVfork ? vfork() : fork();
-#else
-    pid_t pid = fork();
-#endif
-    if (pid != 0) return pid;
-    fun();
-    abort();
-}
-
-
-pid_t startProcess(std::function<void()> fun, const ProcessOptions & options)
-{
-    auto wrapper = [&]() {
-        if (!options.allowVfork) _writeToStderr = 0;
-        try {
-#if __linux__
-            if (options.dieWithParent && prctl(PR_SET_PDEATHSIG, SIGKILL) == -1)
-                throw SysError("setting death signal");
-#endif
-            restoreAffinity();
-            fun();
-        } catch (std::exception & e) {
-            try {
-                std::cerr << options.errorPrefix << e.what() << "\n";
-            } catch (...) { }
-        } catch (...) { }
-        if (options.runExitHandlers)
-            exit(1);
-        else
-            _exit(1);
-    };
-
-    pid_t pid = doFork(options.allowVfork, wrapper);
-    if (pid == -1) throw SysError("unable to fork");
-
-    return pid;
-}
-
-
 std::vector<const char *> stringsToCharPtrs(const Strings & ss)
 {
     std::vector<const char *> res;
@@ -921,91 +474,8 @@ std::vector<const char *> stringsToCharPtrs(const Strings & ss)
 }
 
 
-string runProgram(Path program, bool searchPath, const Strings & args)
-{
-    checkInterrupt();
-
-    /* Create a pipe. */
-    Pipe pipe;
-    pipe.create();
-
-    /* Fork. */
-    Pid pid = startProcess([&]() {
-        if (dup2(pipe.writeSide, STDOUT_FILENO) == -1)
-            throw SysError("dupping stdout");
-
-        Strings args_(args);
-        args_.push_front(program);
-        auto cargs = stringsToCharPtrs(args_);
-
-        if (searchPath)
-            execvp(program.c_str(), (char * *) &cargs[0]);
-        else
-            execv(program.c_str(), (char * *) &cargs[0]);
-
-        throw SysError(format("executing ‘%1%’") % program);
-    });
-
-    pipe.writeSide.close();
-
-    string result = drainFD(pipe.readSide);
-
-    /* Wait for the child to finish. */
-    int status = pid.wait(true);
-    if (!statusOk(status))
-        throw ExecError(format("program ‘%1%’ %2%")
-            % program % statusToString(status));
-
-    return result;
-}
-
-
-void closeMostFDs(const set<int> & exceptions)
-{
-    int maxFD = 0;
-    maxFD = sysconf(_SC_OPEN_MAX);
-    for (int fd = 0; fd < maxFD; ++fd)
-        if (fd != STDIN_FILENO && fd != STDOUT_FILENO && fd != STDERR_FILENO
-            && exceptions.find(fd) == exceptions.end())
-            close(fd); /* ignore result */
-}
-
-
-void closeOnExec(int fd)
-{
-    int prev;
-    if ((prev = fcntl(fd, F_GETFD, 0)) == -1 ||
-        fcntl(fd, F_SETFD, prev | FD_CLOEXEC) == -1)
-        throw SysError("setting close-on-exec flag");
-}
-
-
-void restoreSIGPIPE()
-{
-    struct sigaction act;
-    act.sa_handler = SIG_DFL;
-    act.sa_flags = 0;
-    sigemptyset(&act.sa_mask);
-    if (sigaction(SIGPIPE, &act, 0)) throw SysError("resetting SIGPIPE");
-}
-
-
-//////////////////////////////////////////////////////////////////////
-
-
-volatile sig_atomic_t _isInterrupted = 0;
-
-void _interrupted()
-{
-    /* Block user interrupts while an exception is being handled.
-       Throwing an exception while another exception is being handled
-       kills the program! */
-    if (!std::uncaught_exception()) {
-        _isInterrupted = 0;
-        throw Interrupted("interrupted by the user");
-    }
-}
-
+string runProgram(Path program, bool searchPath, const Strings & args) {
+	PWRN("not running program %s", program.c_str()); return ""; }
 
 
 //////////////////////////////////////////////////////////////////////
@@ -1059,32 +529,6 @@ string chomp(const string & s)
 }
 
 
-string statusToString(int status)
-{
-    if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {
-        if (WIFEXITED(status))
-            return (format("failed with exit code %1%") % WEXITSTATUS(status)).str();
-        else if (WIFSIGNALED(status)) {
-            int sig = WTERMSIG(status);
-#if HAVE_STRSIGNAL
-            const char * description = strsignal(sig);
-            return (format("failed due to signal %1% (%2%)") % sig % description).str();
-#else
-            return (format("failed due to signal %1%") % sig).str();
-#endif
-        }
-        else
-            return "died abnormally";
-    } else return "succeeded";
-}
-
-
-bool statusOk(int status)
-{
-    return WIFEXITED(status) && WEXITSTATUS(status) == 0;
-}
-
-
 bool hasSuffix(const string & s, const string & suffix)
 {
     return s.size() >= suffix.size() && string(s, s.size() - suffix.size()) == suffix;
diff --git a/src/libutil/util.hh b/src/libutil/util.hh
index 186ee71..3690bda 100644
--- a/src/libutil/util.hh
+++ b/src/libutil/util.hh
@@ -2,18 +2,22 @@
 
 #include "types.hh"
 
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <dirent.h>
-#include <unistd.h>
-#include <signal.h>
 #include <functional>
 
 #include <cstdio>
 
+/* Genode includes */
+#include <vfs/file_system.h>
+#include <vfs/vfs_handle.h>
 
 namespace nix {
 
+typedef vector<Vfs::Directory_service::Dirent> DirEntries;
+
+#define S_ISDIR(m) (((m) & 0170000) == 0040000)    /* directory */
+#define S_ISREG(m) (((m) & 0170000) == 0100000)    /* regular file */
+#define S_ISLNK(m) (((m) & 0170000) == 0120000)    /* symbolic link */
+
 
 #define foreach(it_type, it, collection)                                \
     for (it_type it = (collection).begin(); it != (collection).end(); ++it)
@@ -25,17 +29,6 @@ namespace nix {
 /* Return an environment variable. */
 string getEnv(const string & key, const string & def = "");
 
-/* Return an absolutized path, resolving paths relative to the
-   specified directory, or the current directory otherwise.  The path
-   is also canonicalised. */
-Path absPath(Path path, Path dir = "");
-
-/* Canonicalise a path by removing all `.' or `..' components and
-   double or trailing slashes.  Optionally resolves all symlink
-   components such that each component of the resulting path is *not*
-   a symbolic link. */
-Path canonPath(const Path & path, bool resolveSymlinks = false);
-
 /* Return the directory part of the given canonical path, i.e.,
    everything before the final `/'.  If the path is the root or an
    immediate child thereof (e.g., `/foo'), this means an empty string
@@ -50,66 +43,84 @@ string baseNameOf(const Path & path);
    directory. */
 bool isInDir(const Path & path, const Path & dir);
 
-/* Get status of `path'. */
-struct stat lstat(const Path & path);
 
-/* Return true iff the given path exists. */
-bool pathExists(const Path & path);
+/* convenience wrapper around the VFS API */
+class Vfs_root
+{
+private:
 
-/* Read the contents (target) of a symbolic link.  The result is not
-   in any way canonicalised. */
-Path readLink(const Path & path);
+    Vfs::File_system &_vfs;
 
-bool isLink(const Path & path);
+    void _deletePath(const Path & path, unsigned long long & bytesFreed);
 
-/* Read the contents of a directory.  The entries `.' and `..' are
-   removed. */
-struct DirEntry
-{
-    string name;
-    ino_t ino;
-    unsigned char type; // one of DT_*
-    DirEntry(const string & name, ino_t ino, unsigned char type)
-        : name(name), ino(ino), type(type) { }
-};
+public:
 
-typedef vector<DirEntry> DirEntries;
+    Vfs_root(Vfs::File_system &vfs);
 
-DirEntries readDirectory(const Path & path);
+    Vfs::File_system &fs();
 
-unsigned char getFileType(const Path & path);
+    /* Canonicalise a path by removing all `.' or `..' components and
+       double or trailing slashes.  Optionally resolves all symlink
+       components such that each component of the resulting path is *not*
+       a symbolic link. */
+    Path canonPath(const Path & path, bool resolveSymlinks = false);
 
-/* Read the contents of a file into a string. */
-string readFile(int fd);
-string readFile(const Path & path, bool drain = false);
+    /* Return an absolutized path, resolving paths relative to the
+       specified directory, or the current directory otherwise.  The path
+       is also canonicalised. */
+    Path absPath(Path path, Path dir = "");
 
-/* Write a string to a file. */
-void writeFile(const Path & path, const string & s);
+    /* Get status of `path'. */
+    Vfs::Directory_service::Stat status(const Path & path);
 
-/* Read a line from a file descriptor. */
-string readLine(int fd);
+    /* Make directory. */
+    void mkdir(const Path & path);
 
-/* Write a line to a file descriptor. */
-void writeLine(int fd, string s);
+    /* Return true iff the given path exists. */
+    bool pathExists(const Path & path);
 
-/* Delete a path; i.e., in the case of a directory, it is deleted
-   recursively.  Don't use this at home, kids.  The second variant
-   returns the number of bytes and blocks freed. */
-void deletePath(const Path & path);
+    /* Read the contents (target) of a symbolic link.  The result is not
+       in any way canonicalised. */
+    Path readLink(const Path & path);
 
-void deletePath(const Path & path, unsigned long long & bytesFreed);
+    bool isLink(const Path & path);
 
-/* Create a temporary directory. */
-Path createTempDir(const Path & tmpRoot = "", const Path & prefix = "nix",
-    bool includePid = true, bool useGlobalCounter = true, mode_t mode = 0755);
+    DirEntries readDirectory(const Path & path);
 
-/* Create a directory and all its parents, if necessary.  Returns the
-   list of created directories, in order of creation. */
-Paths createDirs(const Path & path);
+    /* Read the contents of a file into a string. */
+    string readFile(const Path & path, bool drain = false);
+
+    /* Write a string to a file. */
+    void writeFile(const Path & path, const string & s);
+
+    /* Unlink a file. */
+    void unlink(const Path & path);
+
+    /* Delete a path; i.e., in the case of a directory, it is deleted
+       recursively.  Don't use this at home, kids.  The second variant
+       returns the number of bytes and blocks freed. */
+    void deletePath(const Path & path);
+
+    void deletePath(const Path & path, unsigned long long & bytesFreed);
+
+    /* Create a temporary directory. */
+    Path createTempDir(const Path & tmpRoot = "", const Path & prefix = "nix",
+        bool useGlobalCounter = true);
+
+    /* Create a directory and all its parents, if necessary.  Returns the
+       list of created directories, in order of creation. */
+    Paths createDirs(const Path & path);
+
+    /* Create a symlink. */
+    void createSymlink(const Path & target, const Path & link);
+};
 
-/* Create a symlink. */
-void createSymlink(const Path & target, const Path & link);
 
+/* Read a line from a VFS handle. */
+string readLine(Vfs::Vfs_handle *);
+
+/* Write a line to a VFS handle. */
+void writeLine(Vfs::Vfs_handle *, string s);
 
 template<class T, class A>
 T singleton(const A & a)
@@ -162,23 +173,19 @@ void printMsg_(Verbosity level, const FormatOrString & fs);
 
 void warnOnce(bool & haveWarned, const FormatOrString & fs);
 
-void writeToStderr(const string & s);
-
-extern void (*_writeToStderr) (const unsigned char * buf, size_t count);
-
+//void writeToStderr(const string & s);
 
 /* Wrappers arount read()/write() that read/write exactly the
    requested number of bytes. */
-void readFull(int fd, unsigned char * buf, size_t count);
-void writeFull(int fd, const unsigned char * buf, size_t count);
-void writeFull(int fd, const string & s);
+void readFull(Vfs::Vfs_handle *handle, unsigned char * buf, size_t count);
+void writeFull(Vfs::Vfs_handle *handle, const unsigned char * buf, size_t count);
+void writeFull(Vfs::Vfs_handle *handle, const string & s);
 
 MakeError(EndOfFile, Error)
 
 
-/* Read a file descriptor until EOF occurs. */
-string drainFD(int fd);
-
+/* Read a VFS handle until EOF occurs. */
+string drainFD(Vfs::Vfs_handle *);
 
 
 /* Automatic cleanup of resources. */
@@ -198,127 +205,22 @@ struct AutoDeleteArray
 
 class AutoDelete
 {
-    Path path;
-    bool del;
-    bool recursive;
+    Vfs_root &vfs;
+    Path      path;
+    bool      del;
+    bool      recursive;
 public:
-    AutoDelete(const Path & p, bool recursive = true);
+    AutoDelete(Vfs_root &vfs_root, const Path & p, bool recursive = true);
     ~AutoDelete();
     void cancel();
 };
 
 
-class AutoCloseFD
-{
-    int fd;
-public:
-    AutoCloseFD();
-    AutoCloseFD(int fd);
-    AutoCloseFD(const AutoCloseFD & fd);
-    ~AutoCloseFD();
-    void operator =(int fd);
-    operator int() const;
-    void close();
-    bool isOpen();
-    int borrow();
-};
-
-
-class Pipe
-{
-public:
-    AutoCloseFD readSide, writeSide;
-    void create();
-};
-
-
-class AutoCloseDir
-{
-    DIR * dir;
-public:
-    AutoCloseDir();
-    AutoCloseDir(DIR * dir);
-    ~AutoCloseDir();
-    void operator =(DIR * dir);
-    operator DIR *();
-    void close();
-};
-
-
-class Pid
-{
-    pid_t pid;
-    bool separatePG;
-    int killSignal;
-public:
-    Pid();
-    Pid(pid_t pid);
-    ~Pid();
-    void operator =(pid_t pid);
-    operator pid_t();
-    void kill(bool quiet = false);
-    int wait(bool block);
-    void setSeparatePG(bool separatePG);
-    void setKillSignal(int signal);
-};
-
-
-/* Kill all processes running under the specified uid by sending them
-   a SIGKILL. */
-void killUser(uid_t uid);
-
-
-/* Fork a process that runs the given function, and return the child
-   pid to the caller. */
-struct ProcessOptions
-{
-    string errorPrefix;
-    bool dieWithParent;
-    bool runExitHandlers;
-    bool allowVfork;
-    ProcessOptions() : errorPrefix("error: "), dieWithParent(true), runExitHandlers(false), allowVfork(true) { };
-};
-
-pid_t startProcess(std::function<void()> fun, const ProcessOptions & options = ProcessOptions());
-
-
-/* Run a program and return its stdout in a string (i.e., like the
-   shell backtick operator). */
-string runProgram(Path program, bool searchPath = false,
-    const Strings & args = Strings());
-
-MakeError(ExecError, Error)
-
 /* Convert a list of strings to a null-terminated vector of char
    *'s. The result must not be accessed beyond the lifetime of the
    list of strings. */
 std::vector<const char *> stringsToCharPtrs(const Strings & ss);
 
-/* Close all file descriptors except stdin, stdout, stderr, and those
-   listed in the given set.  Good practice in child processes. */
-void closeMostFDs(const set<int> & exceptions);
-
-/* Set the close-on-exec flag for the given file descriptor. */
-void closeOnExec(int fd);
-
-/* Restore default handling of SIGPIPE, otherwise some programs will
-   randomly say "Broken pipe". */
-void restoreSIGPIPE();
-
-
-/* User interruption. */
-
-extern volatile sig_atomic_t _isInterrupted;
-
-void _interrupted();
-
-void inline checkInterrupt()
-{
-    if (_isInterrupted) _interrupted();
-}
-
-MakeError(Interrupted, BaseError)
-
 
 /* String tokenizer. */
 template<class C> C tokenizeString(const string & s, const string & separators = " \t\n\r");
@@ -334,13 +236,6 @@ string concatStringsSep(const string & sep, const StringSet & ss);
 string chomp(const string & s);
 
 
-/* Convert the exit status of a child as returned by wait() into an
-   error string. */
-string statusToString(int status);
-
-bool statusOk(int status);
-
-
 /* Parse a string into an integer. */
 template<class N> bool string2Int(const string & s, N & n)
 {
